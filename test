[Description("An object responsible for binding a ViewModel property path to the value property of a UI element")]
[COMCreatable(False)]
Class ControlBinding
Option Explicit
Private Const myClass = "ControlBinding"

    Implements IHandlePropertyChanged
    Implements IManagedObject
                              
    Implements ILookupFilterManager
    Implements IControlBinding
    Implements IDisposable

    Public Event AfterUpdate()
    Public Event Hidden()
    Public Event Shown()

    Private WithEvents CheckBoxEventSource As Access.CheckBox
    Attribute CheckBoxEventSource.VB_VarHelpID = -1
    Private WithEvents ComboBoxEventSource As Access.ComboBox
    Attribute ComboBoxEventSource.VB_VarHelpID = -1
    Private WithEvents ComboBoxEventSourceEx As Access.ComboBox
    Attribute ComboBoxEventSourceEx.VB_VarHelpID = -1
    Private WithEvents ListBoxEventSource As Access.ListBox
    Attribute ListBoxEventSource.VB_VarHelpID = -1
    Private WithEvents OptionGroupEventSource As Access.OptionGroup
    Attribute OptionGroupEventSource.VB_VarHelpID = -1
    Private WithEvents TextBoxEventSource As Access.TextBox
    Attribute TextBoxEventSource.VB_VarHelpID = -1
    
    Private Type TDisplayState
        Value As DisplayState
        Frozen As Boolean
    End Type
    
    Private Type TDisplayStore
        Initial As DisplayState
        Formatter As IDisplayStateFormatter
        States() As TDisplayState
        Limit As Long
        Disabled As Long
    End Type
    
    Private Type TGroupOption
        Value As Long
        Formatter As IOptionDisplayStateFormatter
    End Type
    
    Private Type TKeyFilter
        Value As KeyFilter
        Object As IKeyFilter
        Space As Long
    End Type
    
    Private Type TLookupFilter
        Value As Boolean
        Filter As ILookupFilter
        Handler As IHandleLookupFilter
        Items As Collection
    End Type

    Private Type TInternal
        Manager As BindingsManager
        Index As Long
        Target As TObject
        Label As Access.Label
        Mode As BindingMode
        Source As TObject
        Value As TValue
        MaxLength As Long
        Comparer As IComparer
        KeyFilter As TKeyFilter
        Display As TDisplayStore
        Validation As TValidationStore
        Options() As TGroupOption
        Converter As IValueConverter
        Lookup As TLookupFilter
        Valid As Boolean
        Applied As Boolean
        StateOnly As Boolean
    End Type

    Private this As TInternal
    
    '****************** NEW ******************
    Sub New(ByVal Manager As BindingsManager, Index As Long, ByVal Target As Object, ByVal SourceProperty As String, ByVal Mode As BindingMode, ByVal Display As DisplayState, ByVal Validator As IValueValidator, ByVal Converter As IValueConverter, ByVal DisplayFormatter As IDisplayStateFormatter, ByVal ErrorFormatter As IValidationErrorFormatter, ByVal MaxLen As Long, ByVal Key As Variant, ByVal Lookup As Boolean, ByVal CaseSensitive As Boolean, ByVal ErrorProperty As String)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".New"
    '==================================================================
    1   Set this.Target.Object = Target
    2   this.Target.PropertyName = "Value"
    3   this.Source.PropertyName = SourceProperty
    4   this.Mode = Mode
    '---------------------------------------
    5   Set this.Manager = Manager
    6   Set this.Converter = Converter
    7   this.Validation = CreateValidationStore(Index, SourceProperty, Validator, ErrorFormatter, ErrorProperty)
    '---------------------------------------
    8   ReDim this.Display.States(0) As TDisplayState
    9   this.Display.Initial = Display
    10  Set this.Display.Formatter = DisplayFormatter
    '---------------------------------------
    11  Me.CaseSensitive = CaseSensitive
    12  this.Valid = True
    '---------------------------------------
    13  Select Case True
    '       --------------------------------
            Case TypeOf Target Is Access.TextBox
    '       --------------------------------
    14          Set TextBoxEventSource = Target
    15          TextBoxEventSource.AfterUpdate = Evented
                If (Target.Controls.Count = 1) Then TextBoxEventSource.OnGotFocus = Evented: TextBoxEventSource.OnLostFocus = Evented: Set this.Label = Target.Controls(0)
    16          If (Not (TextBoxEventSource.Format = vbNS)) Then
    17              Select Case TextBoxEventSource.Format
                        Case "General Date", "Short Date", "Medium Date", "Long Date", "Short Time", "Medium Time", "Long Time"
    18                      this.Value.Default = IIf(Target.DefaultValue = vbNS, Null, CDate(Target.DefaultValue)): this.Value.Null = DEFAULT_DATE
                        Case "True/False", "Yes/No"
    19                      this.Value.Default = IIf(Target.DefaultValue = vbNS, Null, CDate(Target.DefaultValue)): this.Value.Null = False
                        Case "General Number"
    20                      this.Value.Default = IIf(Target.DefaultValue = vbNS, Null, CLng(Target.DefaultValue)): this.Value.Null = 0
                        Case Else: GoTo 23
    21              End Select
    22          Else
    23              this.Value.Default = IIf(Target.DefaultValue = vbNS, Null, CStr(Target.DefaultValue))
    24              this.Value.Null = vbNS
                End If
    26          If (MaxLen > 0) Then
    27              TextBoxEventSource.OnChange = Evented
    28              this.MaxLength = MaxLen
                End If
    30          If Not IsEmpty(Key) Then
    31              TextBoxEventSource.OnKeyPress = Evented
    32              ResolveInitialKeyFilter Key
                End If
    '       --------------------------------
            Case TypeOf Target Is Access.ComboBox
    '       --------------------------------
    37          this.Value = GetValueListValueType(Target)
                this.Lookup.Value = Lookup
                If Lookup Then Set this.Lookup.Items = New Collection
    35          Set ComboBoxEventSource = Target
    36          ComboBoxEventSource.AfterUpdate = Evented
                If (Target.Controls.Count = 1) Then ComboBoxEventSource.OnGotFocus = Evented: ComboBoxEventSource.OnLostFocus = Evented: Set this.Label = Target.Controls(0)
    38          If (MaxLen > 0) Then
    39              ComboBoxEventSource.OnChange = Evented
    40              this.MaxLength = MaxLen
                End If
    42          If Not IsEmpty(Key) Then
    43              ComboBoxEventSource.OnKeyPress = Evented
    44              ResolveInitialKeyFilter Key
                End If
    '       --------------------------------
            Case TypeOf Target Is Access.OptionGroup
    '       --------------------------------
                ConfigureOptionStates
    45          Set OptionGroupEventSource = Target: OptionGroupEventSource.AfterUpdate = Evented: OptionGroupEventSource.OnEnter = Evented: OptionGroupEventSource.OnExit = Evented
                Set this.Label = Target.Controls(0)
    51          this.Value.Default = IIf(Target.DefaultValue = vbNS, 0, CLng(Target.DefaultValue))
    52          this.Value.Null = 0
    '       --------------------------------
            Case TypeOf Target Is Access.ListBox
    '       --------------------------------
    53          Set ListBoxEventSource = Target: ListBoxEventSource.AfterUpdate = Evented: ListBoxEventSource.OnKeyDown = Evented
                If (Target.Controls.Count = 1) Then ListBoxEventSource.OnGotFocus = Evented: ListBoxEventSource.OnLostFocus = Evented: Set this.Label = Target.Controls(0)
    56          this.Value = GetValueListValueType(Target)
    '       --------------------------------
            Case TypeOf Target Is Access.CheckBox
    '       --------------------------------
    58          Set CheckBoxEventSource = Target
    59          CheckBoxEventSource.AfterUpdate = Evented: CheckBoxEventSource.OnKeyPress = Evented
    61          this.Value.Default = IIf(Target.DefaultValue = vbNS, False, CBool(Target.DefaultValue))
    62          this.Value.Null = False
    '       --------------------------------
            Case Else
    '       --------------------------------
    63          Err.Raise vbObjectError, myClass & ".New", TypeName(Me) & ": Target of type '" & TypeName(Target) & "' is not currently supported for control bindings"
        End Select
    '---------------------------------------
    66  ConfigureReadWriteStrategy TypeName(this.Value.Null), this.Target.ReadWriteStrategy, this.Source.ReadWriteStrategy
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub

    '*************** INTERFACE ***************
    Private Sub IDisposable_Dispose()
        Set CheckBoxEventSource = Nothing
        Set ComboBoxEventSource = Nothing
        Set ComboBoxEventSourceEx = Nothing
        Set ListBoxEventSource = Nothing
        Set OptionGroupEventSource = Nothing
        Set TextBoxEventSource = Nothing
    '---------------------------------------
        If this.Lookup.Value Then
            Set this.Lookup.Handler = Nothing
            Set this.Lookup.Filter = Nothing
            Terminates this.Lookup.Items
        End If
    '---------------------------------------                     
        If Not this.Validation.Validator Is Nothing Then
            If (Not (this.Validation.Formatter Is this.Display.Formatter)) Then Terminate this.Validation.Formatter Else Set this.Validation.Formatter = Nothing
            Set this.Validation.Handler = Nothing
            TerminateEx this.Validation.Validator
            Set this.Validation.Error = Nothing
        End If
    '---------------------------------------
        Terminate this.Display.Formatter
        Erase this.Display.States
    '---------------------------------------
        If TypeOf this.Target.Object Is Access.OptionGroup Then
            Dim i As Long: For i = 1 To UBound(this.Options): Terminate(this.Options(i).Formatter): Next
            Erase this.Options
        End If
    '---------------------------------------
        Set this.Label = Nothing
        Set this.Target.Object = Nothing
        Set this.Target.ReadWriteStrategy = Nothing
        Set this.Source.Object = Nothing
        Set this.Source.ReadWriteStrategy = Nothing
        Set this.Manager = Nothing
        Set this.KeyFilter.Object = Nothing
        Set this.Converter = Nothing
        Set this.Comparer = Nothing
    End Sub
    
    '*************** INTERFACE ***************
    Private Property Get IControlBinding_Target() As Object
        Set IControlBinding_Target = this.Target.Object
    End Property
    
    Private Property Get IControlBinding_TargetProperty() As String
        IControlBinding_TargetProperty = this.Target.PropertyName
    End Property
    
    Private Property Get IControlBinding_SourceProperty() As String
        IControlBinding_SourceProperty = this.Source.PropertyName
    End Property
    
    Private Property Get IControlBinding_ErrorProperty() As String
        IControlBinding_ErrorProperty = this.Validation.Error.PropertyName
    End Property
    Private Property Let IControlBinding_ErrorProperty(ByVal Value As String)
        this.Validation.Error.PropertyName = Value
    End Property
    
    Private Property Get IControlBinding_MaxLength() As Long
        IControlBinding_MaxLength = this.MaxLength
    End Property
    Private Property Let IControlBinding_MaxLength(ByVal Value As Long)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".MaxLength"
    '==================================================================
    1   If (Not (this.MaxLength = Value)) Then
    2       If (this.MaxLength = 0) Then
    3           CallByName EventSource, "OnChange", vbLet, Evented ' A previous max Length has not been set so add the needed events
    4       ElseIf (Value = 0) Then
    5           CallByName EventSource, "OnChange", vbLet, vbNS ' A previous Length has been set, that now needs to be removed
            End If
    6       this.MaxLength = Value ' Set the new value for the max Length
        End If
        Exit Property
    '==================================================================
    ERR_:
        HandleError myName
    End Property
    
    Private Property Get IControlBinding_KeyFilter() As KeyFilter
        IControlBinding_KeyFilter = this.KeyFilter.Value
    End Property
    Private Property Let IControlBinding_KeyFilter(ByVal Value As KeyFilter)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".KeyFilter"
    '==================================================================
    1   If (Not (this.KeyFilter.Value = Value)) Then
    2       Set this.KeyFilter.Object = Nothing
    3       If (Value = None) Then
    4           this.KeyFilter.Space = 0
    5           CallByName EventSource, "OnKeyPress", vbLet, vbNS ' A previous key filter has been set, so the OnKeyPress event needs to be disconnected
            Else
    6           If (this.KeyFilter.Value = None) Then CallByName EventSource, "OnKeyPress", vbLet, Evented
    7           Set this.KeyFilter.Object = ServiceProvider.GetService(KeyFilterToString(Value, this.Target.Object.Name, this.KeyFilter.Space))
            End If
    8       this.KeyFilter.Value = Value
        End If
        Exit Property
    '==================================================================
    ERR_:
        HandleError myName
    End Property
    
    Private Property Get IControlBinding_Column(ByVal Index As Long) As Variant
        IControlBinding_Column = this.Target.Object.Column(Index)
    End Property
    
    Private Sub IControlBinding_Requery()
        this.Target.Object.Requery
    End Sub
    
    Private Sub IControlBinding_Reset()
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".Reset"
    '==================================================================
    1   If Not this.Display.States(0).Frozen Then
    2       this.Target.Object.Value = this.Value.Default
    3       ApplyControlDisplay this.Display.Initial
            If Not OptionGroupEventSource Is Nothing Then
                Dim i As Long
                For i = 1 To UBound(this.Options)
                    
                Next
            End If
        End If
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub
    
    Private Sub IControlBinding_SetFocus()
        If ((this.Display.States(0).Value = Default) Or (this.Display.States(0).Value = ReadOnly)) Then this.Target.Object.SetFocus
    End Sub
    
    Private Property Get IControlBinding_Display(Optional ByVal Index As Long) As DisplayState
        IControlBinding_Display = this.Display.States(Index).Value
    End Property
    Private Property Let IControlBinding_Display(Optional ByVal Index As Long, ByVal Value As DisplayState)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".Display"
    '------------------------------------------------------------------
    If (this.Display.States(Index).Value = Value) Then Exit Property
    If this.Display.States(0).Frozen Then Exit Property
    '==================================================================
    1   If (Index = 0) Then
    2       ApplyControlDisplay Value
        Else
    3       ApplyOptionDisplay this.Display.States(Index), this.Options(Index), Value
        End If
        Exit Property
    '==================================================================
    ERR_:
        HandleError myName
    End Property
    
    Private Property Get IControlBinding_IsValid() As Boolean
        IControlBinding_IsValid = this.Valid
    End Property
    
    Private Sub IControlBinding_Freeze(Optional ByVal Index As Long)
        this.Display.States(Index).Frozen = True
    End Sub
    Private Sub IControlBinding_Unfreeze(Optional ByVal Index As Long)
        this.Display.States(Index).Frozen = False
    End Sub
    
    Private Sub IControlBinding_ChangeLookupFilter(ByVal Key As String)
        If this.Lookup.Items.Exists(Key) Then
            Dim Lookup As ILookupFilter = this.Lookup.Items(Key)
            If this.Lookup.Filter Is Lookup Then Exit Sub
            Set ComboBoxEventSource = Nothing
            Set ComboBoxEventSourceEx = this.Target.Object
        End If
    End Sub
    
    Private Sub IControlBinding_RemoveLookupFilter()
        
    End Sub
    
    Private Sub IControlBinding_UpdateLimitToList(ByVal Value As Boolean)
        this.Target.Object.LimitToList = Value
    End Sub
    
    Private Sub IControlBinding_UpdateList(ByVal RowSource As String, Optional ByVal ColumnCount As Long = 1, Optional ByVal ColumnWidths As String, Optional ByVal ColumnHeads As Boolean, Optional ByVal LimitToList As Boolean = True, Optional ByVal RowSourceType As RowSourceType = ValueList)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".UpdateList"
    '==================================================================
    1   Dim Value As String = Choose(RowSourceType + 1, "Value List", "Table/Query", "Field List")
    2   If Not (this.Target.Object.RowSource = RowSource) Then
    3       this.Target.Object.ColumnHeads = ColumnHeads
    4       this.Target.Object.ColumnWidths = ColumnWidths
    5       this.Target.Object.CoulmnCount = ColumnCount
    6       this.Target.Object.RowSource = RowSource
    7       If (Not (this.Target.Object.RowSourceType = Value)) Then this.Target.Object.RowSourceType = Value
    9       If Not (this.Target.Object.LimitToList = LimitToList) Then this.Target.Object.LimitToList = LimitToList
    8       If (this.Target.Object.RowSourceType = "Table/Query") Then this.Target.Object.Requery
        End If
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub
    
    Private Sub IControlBinding_UpdateValidator(ByVal Pattern As String, Optional ByVal Message As String)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".UpdateValidator"
    '------------------------------------------------------------------
    If this.Validation.Validator Is Nothing Then Exit Sub
    If Not TypeOf this.Validation.Validator Is ValidateRequiredPattern Then Exit Sub
    '==================================================================
    1   Dim Validator As ValidateRequiredPattern = this.Validation.Validator
    2   If Not (Validator.RegEx.Pattern = Pattern) Then
    3       Validator.RegEx.Pattern = Pattern
    4       If (Not (Message = vbNS)) Then this.Validation.Error.Message = Message
    5       If (this.Display.States(0).Value = Default) Then Validate TryReadSourcePropertyValue(), this.Valid
        End If
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub
    
    Private Function IControlBinding_LookupProperty(ByVal PropertyName As String) As Variant
        AssignResult IControlBinding_LookupProperty, CallByName(this.Target.Object, PropertyName, vbGet)
    End Function
    
    Private Sub IControlBinding_UpdateProperty(ByVal PropertyName As String, ByVal Value As Variant)
        CallByName this.Target.Object, PropertyName, IIf(IsObject(Value), vbSet, vbLet), Value
    End Sub
    
    Private Sub IControlBinding_ChangeValidator(ByVal Validator As IValueValidator)
        If Not Validator Is Nothing Then
            If Not this.Validation.Validator Is Nothing Then
                If Validator Is this.Validation.Validator Then Exit Sub
                TerminateEx this.Validation.Validator
            End If
            Set this.Validation.Validator = Validator
            Validate TryReadSourcePropertyValue(), this.Valid
        Else
            TerminateEx this.Validation.Validator
            this.Validation.Handler.Clear this.Source.PropertyName
        End If
    End Sub
    
    Private Sub IControlBinding_ChangeKeyFilter(ByVal KeyFilter As IKeyFilter)
        If Not KeyFilter Is Nothing Then
            If Not this.KeyFilter.Object Is Nothing Then
                If KeyFilter Is this.KeyFilter.Object Then Exit Sub
                TerminateEx this.KeyFilter.Object
            Else
                CallByName EventSource, "OnKeyPress", vbLet, Evented
            End If
            this.KeyFilter.Value = CustomFilter
        Else
            this.KeyFilter.Value = None
            If Not this.KeyFilter.Object Is Nothing Then
                CallByName EventSource, "OnKeyPress", vbLet, vbNS
                TerminateEx this.KeyFilter.Object
            End If
        End If
        Set this.KeyFilter.Object = KeyFilter
        this.KeyFilter.Space = 0
    End Sub

    '************** PROPERTIES ***************
    Private Property Let Display(ByVal Value As DisplayState)
        If (Not (this.Display.States(0).Value = Value)) Then If (Not this.Display.Formatter Is Nothing) And (Not (Value = Default)) Then ApplyControlDisplay Value
    End Property

    Private Property Let CaseSensitive(ByVal Value As Boolean)
        If Value Then Set this.Comparer = ServiceProvider.GetService("CompareStrings") Else Set this.Comparer = ServiceProvider.GetService("CompareValues")
    End Property
    
    Private Property Set Source(ByVal RHS As Object)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".Source"
    '================================================================== 
    1   Set this.Source.Object = RHS
    2   Set this.Validation.Handler = CType(Of IViewModel)(RHS).Manager.Validation
    3   If TypeOf this.Target.Object Is IHandleValidationChanged Then
    4       CType(Of INotifyValidationChanged)(this.Validation.Handler).RegisterHandler this.Target.Object
        End If
    5   this.Applied = False
        Exit Property
    '==================================================================
    ERR_:
        HandleError myName
    End Property
                              
    Private Property Get EventSource() As Object
        Select Case True
            Case Not TextBoxEventSource Is Nothing: Return TextBoxEventSource
            Case Not ComboBoxEventSource Is Nothing: Return ComboBoxEventSource
            Case Not OptionGroupEventSource Is Nothing: Return OptionGroupEventSource
            Case Not ComboBoxEventSourceEx Is Nothing: Return ComboBoxEventSourceEx
            Case Not CheckBoxEventSource Is Nothing: Return CheckBoxEventSource
            Case Not ListBoxEventSource Is Nothing: Return ListBoxEventSource
            Case Else: Return Nothing
        End Select
    End Property
    
    '**************** METHODS ****************
    Public Function Apply(ByVal Context As Object, SourceProperty As String) As IManagedObject
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".Apply"
    '==================================================================
    1   If Not this.Applied Then
    2       Set Me.Source = Context
    3        If IsEmpty(this.Value.Null) Then
    4           Select Case VarType(CallByName(Context, this.Source.PropertyName, vbGet))
                    Case vbString: this.Value.Null = vbNS
                    Case vbLong: this.Value.Null = 0
                    Case vbBoolean: this.Value.Null = False
                    Case vbDate: this.Value.Null = DEFAULT_DATE
                End Select
    5           ConfigureReadWriteStrategy(TypeName(this.Value.Null), this.Target.ReadWriteStrategy, this.Source.ReadWriteStrategy)
            End If
    6       If (Not (this.Mode = OneWayToSource)) Then
    7           SourceProperty = this.Source.PropertyName
    8          Set Apply = Me
            End If
        Else
    9      If (Not (this.Mode = OneWayToSource)) Then ApplyToTarget TryReadSourcePropertyValue()
        End If
        Exit Function
    '==================================================================
    ERR_:
        HandleError myName
    End Function
    
    Public Sub Validate()
        Validate TryReadSourcePropertyValue(), this.Valid
    End Sub
    
    '*************** INTERFACE ***************
    Private Sub IManagedObject_Apply(ByVal Context As Object)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".IManagedObject.Apply"
    '==================================================================
    1   If (Not (this.Display.Initial = Default)) Then ApplyControlDisplay this.Display.Initial
    2   If (Not (this.Mode = OneWayToSource)) Then
    3       ApplyToTarget TryReadSourcePropertyValue()
        Else
    4       ApplyToSource
        End If
    5   this.Applied = True
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub

    '*************** INTERFACE ***************
    Private Sub IHandlePropertyChanged_OnPropertyChanged(ByVal Value As Variant)
        ApplyToTarget Value
    End Sub

    Private Sub BeforeUpdate(Cancel As Integer) Handles CheckBoxEventSource.BeforeUpdate, ComboBoxEventSource.BeforeUpdate, ComboBoxEventSourceEx.BeforeUpdate, ListBoxEventSource.BeforeUpdate, OptionGroupEventSource.BeforeUpdate, TextBoxEventSource.BeforeUpdate
        
    End Sub

    '**************** EVENTS *****************
    Private Sub OnAfterUpdate() Handles CheckBoxEventSource.AfterUpdate, ComboBoxEventSource.AfterUpdate, ListBoxEventSource.AfterUpdate, OptionGroupEventSource.AfterUpdate, TextBoxEventSource.AfterUpdate
    On Error GoTo FAILED_
        ApplyToSource
        Exit Sub
    FAILED_:
        On Error GoTo 0
    End Sub
    
    Private Sub OnAfterUpdateEx() Handles ComboBoxEventSourceEx.AfterUpdate
    On Error GoTo FAILED_
        this.Lookup.Handler.AfterUpdate()
        ApplyToSource
        Exit Sub
    FAILED_:
        On Error GoTo 0
    End Sub
    
    Private Sub OnGotFocus() Handles ComboBoxEventSourceEx.GotFocus, ComboBoxEventSource.GotFocus, ListBoxEventSource.GotFocus, OptionGroupEventSource.Enter, TextBoxEventSource.GotFocus
        this.Label.ForeColor = FOCUSED_LABEL_FORECOLOR
    End Sub
    
    Private Sub OnLostFocus() Handles ComboBoxEventSourceEx.LostFocus, ComboBoxEventSource.LostFocus, ListBoxEventSource.LostFocus, TextBoxEventSource.LostFocus
        this.Label.ForeColor = NORMAL_LABEL_FORECOLOR
    End Sub
    
    Private Sub OnExit(Cancel As Integer) Handles OptionGroupEventSource.Exit
        this.Label.ForeColor = NORMAL_LABEL_FORECOLOR
    End Sub
    
    Private Sub OnChange() Handles ComboBoxEventSource.Change, TextBoxEventSource.Change
        If (Len(this.Target.Object.Text) > this.MaxLength) Then
            this.Target.Object.Text = Left(this.Target.Object.Text, this.MaxLength)
            this.Target.Object.SelStart = this.MaxLength
        End If
    End Sub
    
    Private Sub OnChangeEx() Handles ComboBoxEventSourceEx.Change
        If (Len(this.Target.Object.Text) > this.MaxLength) Then
            this.Target.Object.Text = Left(this.Target.Object.Text, this.MaxLength)
            this.Target.Object.SelStart = this.MaxLength
        Else
            this.Lookup.Handler.Change()
        End If
    End Sub
    
    Private Sub OnKeyPress(KeyAscii As Integer) Handles ComboBoxEventSource.KeyPress, ComboBoxEventSourceEx.KeyPress, TextBoxEventSource.KeyPress
        this.KeyFilter.Object.Apply(KeyAscii, this.KeyFilter.Space)
        If ((this.MaxLength > 0) And (KeyAscii > 0)) Then If ((Len(this.Target.Object.Text) - this.Target.Object.SelLength) >= this.MaxLength) Then If Not (KeyAscii = vbKeyBack) Then KeyAscii = 0
    End Sub
    
    Private Sub OnKeyPress2(KeyAscii As Integer) Handles CheckBoxEventSource.KeyPress, ListBoxEventSource.KeyPress
        If (KeyAscii = vbKeyReturn) Then   ' ENTER
            this.Target.Object.Value = Not this.Target.Object.Value
            AfterUpdate
        End If
    End Sub
    
    '**************** EVENTS *****************
    Private Sub ListBoxEventSource_KeyDown(KeyCode As Integer, Shift As Integer)
        Select Case KeyCode
            Case vbKeyEnd: ListBoxScrollEvent this.Target.Object.ListCount - 1
            Case vbKeyHome: ListBoxScrollEvent 0
            Case vbKeyReturn: KeyCode = 0: Dim ListIndex As Long = this.Target.Object.ListIndex: this.Target.Object.Selected(ListIndex) = Not this.Target.Object.Selected(ListIndex)
        End Select
    End Sub

    Private Sub ListBoxScrollEvent(ScrollTo As Long)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".ListBoxScrollEvent"
    '==================================================================
    1   Dim Selected As Boolean = this.Target.Object.Selected(ScrollTo)
    2   Dim Value As Variant = this.Target.Object.Value
    3   this.Target.Object.Selected(ScrollTo) = True
    4   If Not Selected Then
    5       this.Target.Object.Selected(ScrollTo) = False
    6       this.Target.Object.Value = Value
        End If
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub

    '**************** METHODS ****************
    [Description("Since all descendents are included in the 'Controls' property of an access control, we need to find the ones that are children. Ex: We need to find only the option buttons in a option group controls property.")]
    Private Sub ConfigureOptionStates()
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".ConfigureOptionStates"
    '==================================================================
        Dim Control As Object
        Dim UB As Long
    1   For Each Control In this.Target.Object.Controls
    2       If (Not (Control.ControlType = acLabel)) Then
    3           UB = UBound(this.Display.States) + 1
    4           ReDim Preserve this.Display.States(0 To UB) As TDisplayState
    5           ReDim Preserve this.Options(1 To UB) As TGroupOption: this.Options(UB).Value = Control.OptionValue
                If TypeOf Control Is Access.ToggleButton Then
    6               Set this.Options(UB).Formatter = New GroupOptionFormatter(Control, Control)
                Else
    7               Set this.Options(UB).Formatter = New GroupOptionFormatter(Control, Control.Controls(0))
                End If
            End If
        Next
        this.Display.Limit = UB - 1
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub
    
    Private Sub AfterUpdate()
    On Error GoTo FAILED_
        ApplyToSource
        Exit Sub
    FAILED_:
        On Error GoTo 0
    End Sub
    
    Private Sub ResolveInitialKeyFilter(ByVal Filter As Variant)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".ResolveInitialKeyFilter"
    '==================================================================
    1   If IsObject(Filter) Then
    2       this.KeyFilter.Value = CustomFilter
    3       Set this.KeyFilter.Object = Filter
        Else
    4       this.KeyFilter.Value = Filter
    5       Set this.KeyFilter.Object = ServiceProvider.GetService(KeyFilterToString(Filter, this.Target.Object.Name, this.KeyFilter.Space))
        End If
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub

    Private Sub ApplyControlDisplay(ByVal Value As DisplayState)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".ApplyControlDisplay"
    '==================================================================
        Dim Previous As DisplayState = this.Display.States(0).Value
    1   CallByName this.Display.Formatter, "Apply" & Previous & Value, vbMethod
    2   this.Display.States(0).Value = Value
    '   ---------------------------------------
        Select Case Value
            Case Disabled, Hidden
    3           this.Target.Object.Value = this.Value.Default
    4           If Not this.Source.Object Is Nothing Then AfterUpdate
    5           If Not this.Validation.Handler Is Nothing Then this.Validation.Handler.Clear this.Source.PropertyName
    6           If (Value = Hidden) Then RaiseEvent Hidden Else If (Previous = Hidden) Then RaiseEvent Shown
            Case ReadOnly
    7           If Not this.Validation.Handler Is Nothing Then this.Validation.Handler.Clear this.Source.PropertyName
    8           If (Previous = Hidden) Then RaiseEvent Shown
            Case Default
    9           Validate Nz(this.Target.Object.Value, this.Value.Null), this.Valid
    10          If (Previous = Hidden) Then RaiseEvent Shown
        End Select
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub

    Private Sub ApplyOptionDisplay(Display As TDisplayState, Option As TGroupOption, ByVal Value As DisplayState)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".ApplyOptionDisplay"
    '------------------------------------------------------------------
    If (Not (this.Display.States(0).Value = Default)) Then Exit Sub
    If (Not ((Value = Default) Or (Value = Disabled))) Then Exit Sub
    '==================================================================
    1   CallByName Option.Formatter, "Apply" & Display.Value & Value, vbMethod
    2   If (Display.Value = Disabled) Then
    3       this.Display.Disabled = this.Display.Disabled - 1
    4       Display.Value = Value
        Else
    5       If (Value = Disabled) Then
    6           Display.Value = Value
    7           this.Display.Disabled = this.Display.Disabled + 1
    '           If all but 1 of the option buttons have been disabled, select the last remaining button
    8           If (this.Display.Disabled = this.Display.Limit) Then
                    Dim i As Long
    9               For i = 1 To UBound(this.Display.States)
    10                  If Not (this.Display.States(i).Value = Disabled) Then
    11                      this.Target.Object.Value = this.Options(i).Value
    12                      AfterUpdate
                            Exit For
                        End If
                    Next
                End If
            Else
    13          Display.Value = Value
            End If
        End If
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub

    '**************** METHODS ****************
    Private Sub ApplyToSource()
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".ApplyToSource"
    '------------------------------------------------------------------
    If ((this.Mode = OneTimeBinding) Or (this.Mode = OneWayToTarget)) Then Exit Sub
    '==================================================================
        Dim TargetValue As Variant
        Dim SourceValue As Variant
    1   If Not this.Target.ReadWriteStrategy.Read(this.Target.Object, this.Target.PropertyName, TargetValue) Then Debug.Print myName & ":[" & ToString() & "] failed to read target property Value.": Exit Sub
    2   If Not this.Converter Is Nothing Then TargetValue = this.Converter.ConvertBack(TargetValue)
    3   Validate TargetValue, this.Valid
    4   If Not this.Source.ReadWriteStrategy.Read(this.Source.Object, this.Source.PropertyName, SourceValue) Then Debug.Print myName & ":[" & ToString() & "] failed to read current source property Value.": Exit Sub
    5   TargetValue = Nz(TargetValue, this.Value.Null)
    6   If (TargetValue <> SourceValue) Then
    7       If Not this.Validation.Handler Is Nothing Then If Not this.Validation.Validator Is Nothing Then If this.Valid Then this.Validation.Handler.Clear this.Source.PropertyName
    8       If Not this.Source.ReadWriteStrategy.Write(this.Source.Object, this.Source.PropertyName, TargetValue) Then Debug.Print myName & ":[" & ToString() & "] failed to write to source property.": Exit Sub
    9       RaiseEvent AfterUpdate
    10      this.Manager.OnEvaluateCanExecute
        End If
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub

    Private Sub ApplyToTarget(ByVal SourceValue As Variant)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".ApplyToTarget"
    '------------------------------------------------------------------
    ' One-way to source and already-applied one-time binding modes do not apply to target
    If ((this.Mode = OneWayToSource) Or (this.Mode = OneTimeBinding And this.Applied)) Then Exit Sub
    '==================================================================
        Dim TargetValue As Variant
    1   Validate SourceValue, this.Valid
    2   If Not this.Converter Is Nothing Then SourceValue = this.Converter.Convert(SourceValue)
        On Error Resume Next
    3   If this.Target.ReadWriteStrategy.Read(this.Target.Object, this.Target.PropertyName, TargetValue) Then
    4       If this.Comparer.IsEqual(SourceValue, TargetValue) Then Exit Sub
    5       If Not this.Target.ReadWriteStrategy.Write(this.Target.Object, this.Target.PropertyName, SourceValue) Then
    6           Debug.Print "Failed to apply binding for target property 'Value' (source path: " & this.Source.PropertyName & "), target Name: " & this.Target.Object.Name
    7           Err.Clear
            Else
    8           If Not this.Validation.Handler Is Nothing Then If Not this.Validation.Validator Is Nothing Then If this.Valid Then this.Validation.Handler.Clear this.Source.PropertyName
    9           RaiseEvent AfterUpdate
    10          this.Manager.OnEvaluateCanExecute
            End If
    11      On Error GoTo 0
        Else
    12      Debug.Print "Failed to get the target's property '" & this.Target.PropertyName & "' (" & TypeName(this.Target) & ": '" & this.Target.Object.Name & "'); source path: '" & this.Source.PropertyName & "'; " & Err.Description
    13      On Error GoTo 0
    14      Err.Clear
        End If
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub

    Private Function TryReadSourcePropertyValue() As Variant
    '==================================================================
    On Error Resume Next
    Const myName = myClass & ".TryReadSourcePropertyValue"
    '==================================================================
    1   If Not this.Source.ReadWriteStrategy.Read(this.Source.Object, this.Source.PropertyName, TryReadSourcePropertyValue) Then
    2       Debug.Print myName, "Failed to get the source's property 'Value' (" & TypeName(this.Target) & ": '" & this.Target.Object.Name & "'); source path: '" & this.Source.PropertyName & "'; " & Err.Description
    3       On Error GoTo 0
    4       Err.Clear
        End If
        On Error GoTo 0
    End Function

    Private Sub Validate(ByVal Value As Variant, ByVal ValidPreviously As Boolean)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".Validate"
    '------------------------------------------------------------------
    If this.Validation.Validator Is Nothing Then Exit Sub
    If Not (this.Display.States(0).Value = Default) Then Exit Sub
    '==================================================================
        Dim Message As String
    1   this.Valid = this.Validation.Validator.IsValid(Value, this.Source.Object, this.Target.Object, this.Validation.Error.Message)
    2   If this.Valid Then
    3       If Not ValidPreviously Then this.Validation.Formatter.Restore
    4       Exit Sub
        End If
    5   NotifyValidationError Message
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub

    Private Sub NotifyValidationError(ByVal ErrorMessage As String)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".NotifyValidationError"
    '==================================================================
     1  this.Validation.Formatter.Apply this.Validation.Handler.Visible, this.Source.PropertyName, ErrorMessage
     2  this.Validation.Handler.OnError this.Source.PropertyName, this.Validation.Error
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub

    Private Function ToString() As String
        ToString = "Source path '" & this.Source.PropertyName & "' (" & TypeName(this.Source) & "), target property 'Value' (" & TypeName(this.Target) & ")"
    End Function
    
    Private Function ILookupFilterManager_Add(ByVal Lookup As ILookupFilter, ByVal Key As String, Optional ByVal Default As Boolean) As ILookupFilterManager
        this.Lookup.Items.Add Lookup, Key
        If Default Then
            
        End If
        Set ILookupFilterManager_Add = Me
    End Function
End Class

Module LibBindings
Option Explicit
Private Const myModule = "LibBindings"

    Public Enum ControlRequirement
        Required = -1
        None
        NotRequired
        DefaultValue
    End Enum

    Public Type TObject
        Object As Object
        PropertyName As String
        ReadWriteStrategy As IReadWriteStrategy
    End Type
    
    Public Type TValue
        Default As Variant
        Null As Variant
    End Type
    
    Public Type TValidationStore
        Validator As IValueValidator
        Formatter As IValidationErrorFormatter
        Handler As IHandleValidationError
        Error As ValidationError
    End Type
    
    '**************** METHODS ****************   
    Public Function GetValueListValueType(ByVal Target As Object) As TValue
    '==================================================================
    On Error GoTo ERR_
    Const myName = myModule & ".GetValueListValueType"
    '------------------------------------------------------------------
    If (Not (Target.RowSourceType = "Value List")) Then Exit Function
    If (Target.RowSource = vbNS) Then Exit Function
    '==================================================================
    1   Dim Index As Long = (Target.BoundColumn - 1)
    2   Dim Items() As String = Split(Target.RowSource, Choose(Target.SeparatorCharacters + 1, ";", vbNL, ";", ","))
    3   Dim Value As String = Items(Index)
    4   Select Case Left(Value, 1)
            Case """", "'"
    5           GetValueListValueType.Default = IIf(Target.DefaultValue = vbNS, Null, CStr(Target.DefaultValue)): GetValueListValueType.Null = vbNS
            Case "1", "2", "3", "4", "5", "6", "7", "8", "9", "0"
    6           GetValueListValueType.Default = IIf(Target.DefaultValue = vbNS, Null, CLng(Target.DefaultValue)): GetValueListValueType.Null = 0
            Case vbNS
    7           Value = Items(Index * 2): GoTo 4
            Case "#"
    8           If (Right(Value, 1) = "#") Then GetValueListValueType.Default = IIf(Target.DefaultValue = vbNS, Null, CDate(Target.DefaultValue)): GetValueListValueType.Null = DEFAULT_DATE
        End Select
        Exit Function
    '==================================================================
    ERR_:
        HandleError myName
    End Function
    
    Public Function GetTableQueryValueType(Target As Object, Source As TObject) As TValue
    '==================================================================
    On Error GoTo ERR_
    Const myName = myModule & ".GetTableQueryValueType"
    '==================================================================
    1   Select Case CallByName(Source.Object, Source.PropertyName, vbGet)
            Case vbLong
    2           GetTableQueryValueType.Default = IIf(Target.DefaultValue = vbNS, Null, CLng(Target.DefaultValue)): GetTableQueryValueType.Null = 0
            Case vbString
    3           GetTableQueryValueType.Default = IIf(Target.DefaultValue = vbNS, Null, CStr(Target.DefaultValue)): GetTableQueryValueType.Null = vbNS
            Case vbDate
    4           GetTableQueryValueType.Default = IIf(Target.DefaultValue = vbNS, Null, CDate(Target.DefaultValue)): GetTableQueryValueType.Null = DEFAULT_DATE
            Case vbBoolean
    5            GetTableQueryValueType.Default = IIf(Target.Default = vbNS, Null, CBool(Target.DefaultValue)): GetTableQueryValueType.Null = False
        End Select
        Exit Function
    '==================================================================
    ERR_:
        HandleError myName
    End Function

    '**************** METHODS ****************
    Public Sub ConfigureReadWriteStrategy(ByVal TypeName As String, TargetStrategy As IReadWriteStrategy, SourceStrategy As IReadWriteStrategy)
    '-----------------------------------------
    If (TypeName = "Empty") Then Exit Sub
    '-----------------------------------------
        Set TargetStrategy = ServiceProvider.GetService("ReadWrite" & TypeName)
        Set SourceStrategy = ServiceProvider.GetService("ReadWriteSource")
    End Sub
    
    Public Function CreateValidationStore(Index As Long, ByVal SourceProperty As String, ByVal Validator As IValueValidator, ByVal ErrorFormatter As IValidationErrorFormatter, ByVal ErrorProperty As String) As TValidationStore
        If Validator Is Nothing Then Exit Function
        Set CreateValidationStore.Validator = Validator
        Set CreateValidationStore.Formatter = ErrorFormatter
        Index = Index + 1
        Set CreateValidationStore.Error = New ValidationError(Index, IIf(ErrorProperty = vbNS, SourceProperty, ErrorProperty), Validator.Message)
    End Function
End Module
Interface IHandleErrorMessage
Option Explicit
    Property Get Key() As String
    [Description("Gets a string containing all validation error messages")]
    Property Get Errors() As String
End Interface

Interface IHandleValidationChanged
Option Explicit
    [Description("Resets the 'IsValid' property to true")]
    Sub OnValid(ByVal Handler As IHandleErrorMessage)
    [Description("Sets the 'IsValid' property to false")]
    Sub OnInvalid(ByVal Handler As IHandleErrorMessage)
End Interface

Interface INotifyValidationChanged
Option Explicit
    [Description("Registers the specified handler")]
    Sub RegisterHandler(ByVal Handler As IHandleValidationChanged)
End Interface

Interface IHandleValidationError Extends IHandleValidationErrorAttribute
Option Explicit
    Property Get Visible() As Boolean
    Property Let Visible(ByVal Value As Boolean)
    Sub OnError(ByVal SourceProperty As String, ByVal Error As ValidationError)
    Sub Clear(ByVal SourceProperty As String)
End Interface

[Description("A validator that validates that value is not zero")]
[COMCreatable(False)]
Class ValidateRequiredBoolean
Option Explicit
Private Const myClass = "ValidateRequiredBoolean"

    Implements IValueValidator

    Private Type TInternal
        Constructor As Boolean
        Message As String
    End Type

    Private this As TInternal
    
    '****************** NEW ******************
    Sub New(ByVal Constructor As Boolean)
        this.Constructor = Constructor
        this.Message = "Value cannot be " & CStr(Not Constructor)
    End Sub
    
    '*************** INTERFACE ***************
    Private Property Get IValueValidator_Message() As String
        IValueValidator_Message = this.Message
    End Property

    Private Function IValueValidator_IsValid(ByVal Value As Variant, ByVal Source As Object, ByVal Target As Object, Message As String) As Boolean
        IValueValidator_IsValid = (Value = this.Constructor)
        If Not IValueValidator_IsValid Then Message = this.Message
    End Function
End Class

[Description("A validator that validates that value is not zero")]
Class ValidateRequiredLong
Option Explicit
Private Const myClass = "ValidateRequiredLong"

    Implements IValueValidator
    
    Private Const Message = "Value cannot be nothing"
    
    '*************** INTERFACE ***************
    Private Property Get IValueValidator_Message() As String
        IValueValidator_Message = Message
    End Property
    
    Private Function IValueValidator_IsValid(ByVal Value As Variant, ByVal Source As Object, ByVal Target As Object, Message As String) As Boolean
        IValueValidator_IsValid = (Not (Value = 0))
        If Not IValueValidator_IsValid Then Message = Me.Message
    End Function
End Class

[Description("A validator that validates that value is not zero")]
Class ValidateRequiredSupplierNumber
Option Explicit
Private Const myClass = "ValidateRequiredSupplierNumber"

    Implements IValueValidator
    
    '*************** INTERFACE ***************
    Private Property Get IValueValidator_Message() As String
    End Property
    
    Private Function IValueValidator_IsValid(ByVal Value As Variant, ByVal Source As Object, ByVal Target As Object, Message As String) As Boolean
        Select Case Len(Value)
            Case 0: Message = "Value cannot be blank"
            Case 9: IValueValidator_IsValid = Value Like "10*": If Not IValueValidator_IsValid Then Message = "Value is required to start with 10"
            Case Else: Message = IIf(Value Like "10*", "Value must be 9 numbers long", "Value must tart with '10' and be 9 numbers long")
        End Select
    End Function
End Class

[Description("A validator that validates that value is not zero")]
Class ValidateRequiredTaxpayerID
Option Explicit
Private Const myClass = "ValidateRequiredTaxpayerID"

    Implements IValueValidator
    
    '*************** INTERFACE ***************
    Private Property Get IValueValidator_Message() As String
    End Property
    
    Private Function IValueValidator_IsValid(ByVal Value As Variant, ByVal Source As Object, ByVal Target As Object, Message As String) As Boolean
        Select Case Len(Value)
            Case 0: Message = "Value cannot be blank"
            Case 9: IValueValidator_IsValid = True
            Case Else: Message = "Value must be 9 numbers long"
        End Select
    End Function
End Class
                                                                  
[COMCreatable(False)]
Class ValidateRequiredPattern
Option Explicit
Private Const myClass = "ValidateRequiredPattern"

    Implements IValueValidator
    Implements IDisposable

    Public RegEx As VBScript_RegExp_55.RegExp
    
    Private Type TInternal
        Message As String
        Pattern As String
    End Type
        
    Private this As TInternal

    '****************** NEW ******************
    Sub New(ByVal Pattern As String, ByVal Message As String, Optional ByVal IgnoreCase As Boolean = True)
        Set Me.RegEx = New VBScript_RegExp_55.RegExp: Me.RegEx.Global = False: Me.RegEx.IgnoreCase = IgnoreCase: Me.RegEx.Multiline = True
        Me.RegEx.Pattern = Pattern: this.Pattern = Pattern
        this.Message = Message
    End Sub
    
    '*************** INTERFACE ***************
    Private Sub IDisposable_Dispose()
        Set Me.RegEx = Nothing
    End Sub

    '*************** INTERFACE ***************
    Private Property Get IValueValidator_Message() As String
        IValueValidator_Message = this.Message
    End Property

    Private Function IValueValidator_IsValid(ByVal Value As Variant, ByVal Source As Object, ByVal Target As Object, Message As String) As Boolean
        If ((Value = vbNS) And (Not (Me.RegEx.Pattern = DUMMY_PATTERN))) Then Message = "Value cannot be blank": Exit Function
        IValueValidator_IsValid = Me.RegEx.Test(CStr(Value))
        Message = this.Message
    End Function
    
    '**************** METHODS ****************
    Public Sub Reset(ByVal Error As ValidationError)
        Error.Message = this.Message
        Me.RegEx.Pattern = this.Pattern
    End Sub
End Class

[Description("A validator that validates that the string is not empty or a.k.a vbNullString")]
[COMCreatable(False)]
Class ValidateRequiredString
Option Explicit
Private Const myClass = "ValidateRequiredString"

    Implements IValueValidator
    
    Private Const Message = "Value cannot be blank"
    
    '*************** INTERFACE ***************
    Private Property Get IValueValidator_Message() As String
        IValueValidator_Message = Message
    End Property

    Private Function IValueValidator_IsValid(ByVal Value As Variant, ByVal Source As Object, ByVal Target As Object, Message As String) As Boolean
        IValueValidator_IsValid = (Len(Trim(Value)) > 0)
        If Not IValueValidator_IsValid Then Message = Me.Message
    End Function
End Class

[Description("A validator that validates that the string is not empty or a.k.a vbNullString")]
[COMCreatable(False)]
Class ValidateRequiredDate
Option Explicit
Private Const myClass = "ValidateRequiredDate"

    Implements IValueValidator
    
    Private Const Message = "Value cannot be blank"
    
    '*************** INTERFACE ***************
    Private Property Get IValueValidator_Message() As String
        IValueValidator_Message = Message
    End Property

    Private Function IValueValidator_IsValid(ByVal Value As Variant, ByVal Source As Object, ByVal Target As Object, Message As String) As Boolean
    On Error Resume Next
        If Value = DEFAULT_DATE Then
            Message = Me.Message
        Else
            IValueValidator_IsValid = (IsDate(Value) Or (TimeValue(CStr(Value)) = CDate(Value)))
            If Not IValueValidator_IsValid Then Message = "Value must be a valid date"
        End If
    On Error GoTo 0
    End Function
End Class

Class ValidationDelegate
Option Explicit
Private Const myClass = "ValidationDelegate"

    Implements IHandleValidationChanged

    Public Event OnValid(ByVal Handler As IHandleErrorMessage)
    Public Event OnInvalid(ByVal Handler As IHandleErrorMessage)
    
    '*************** INTERFACE ***************
    Private Sub IHandleValidationChanged_OnInvalid(ByVal Handler As IHandleErrorMessage)
        RaiseEvent OnInvalid(Handler)
    End Sub

    Private Sub IHandleValidationChanged_OnValid(ByVal Handler As IHandleErrorMessage)
        RaiseEvent OnValid(Handler)
    End Sub
End Class

[COMCreatable(False)]
Class ValidationError
Option Explicit
    
    Public Index As Long
    Public PropertyName As String
    Public Message As String
    
    Sub New(ByVal Index As Long, ByVal ErrorProperty As String, ByVal Message As String)
        Me.Index = Index
        Me.PropertyName = ErrorProperty
        Me.Message = Message
    End Sub
End Class

[Description("Implements validation helper methods for the ViewModel to consume")]
Class ValidationManager
Option Explicit
Private Const myClass = "ValidationManager"

    Implements INotifyValidationChanged
    Implements IHandleValidationChanged
    Implements IHandleErrorMessage
    
    Implements IHandleValidationError
    Implements IValidationManager
    Implements IDisposable

    Private Type TInternal
        Key As String
        Handlers As Collection
        Errors As Collection
        Formatting As Boolean
        Message As String
        Cleared As Boolean
        ThrowOnValidationError As Boolean
    End Type
    
    Private this As TInternal
    
    '****************** NEW ******************
    Sub New()
        this.Key = CStr(ObjPtr(Me))
        Set this.Handlers = New Collection
        Set this.Errors = New Collection: this.Errors.KeyCompareMode = vbBinaryCompare
    End Sub

    '*************** INTERFACE ***************
    Private Sub IDisposable_Dispose()
    '---------------------------------------
    If this.Handlers Is Nothing Then Exit Sub
    '---------------------------------------
    '   Since this class is terminating we need to remove all of the errors that have sent to the handlers
        'If (Handlers.Count > 0) Then NotifyValidStatusChange Handlers, Me
        Set this.Handlers = Nothing
        Set this.Errors = Nothing
    End Sub
    
    '*************** INTERFACE ***************
    Private Property Get IValidationManager_IsValid() As Boolean
        IValidationManager_IsValid = IIf(this.Cleared, True, (this.Errors.Count = 0))
    End Property
    
    Private Property Get IValidationManager_Formatting() As Boolean
        IValidationManager_Formatting = this.Formatting
    End Property
    Private Property Let IValidationManager_Formatting(ByVal Value As Boolean)
        this.Formatting = Value
    End Property

    '*************** INTERFACE ***************
    Private Property Get IHandleValidationError_Visible() As Boolean
        IHandleValidationError_Visible = this.Formatting
    End Property
    Private Property Let IHandleValidationError_Visible(ByVal Value As Boolean)
        this.Formatting = Value
    End Property

    Private Property Get IHandleValidationError_IsValid() As Boolean
        IHandleValidationError_IsValid = IIf(this.Cleared, True, (this.Errors.Count = 0))
    End Property
    
    Private Sub IHandleValidationError_OnError(ByVal SourceProperty As String, ByVal Error As ValidationError)
        If Not this.Errors.Exists(SourceProperty) Then
            If this.Errors.Count > 0 Then
                Dim i As Long
                For i = 1 To this.Errors.Count
                    If this.Errors(i).Index > Error.Index Then
                        this.Errors.Add Error, SourceProperty, i
                        GoTo MESSAGE_
                    End If
                Next
                this.Errors.Add Error, SourceProperty
            Else
                this.Errors.Add Error, SourceProperty
            End If
MESSAGE_:   this.Message = Error.PropertyName & " - " & Error.Message
            If (this.Errors.Count = 1) Then NotifyInvalidStatusChange this.Handlers, Me
        End If
    End Sub

    Private Sub IHandleValidationError_Clear(ByVal SourceProperty As String)
        If this.Errors.Exists(SourceProperty) Then
            this.Errors.Remove SourceProperty
            If (this.Errors.Count = 0) Then
                this.Message = vbNS
                NotifyValidStatusChange this.Handlers, Me
            End If
        End If
    End Sub
    
    '*************** INTERFACE ***************
    Private Property Get IHandleErrorMessage_Key() As String
        IHandleErrorMessage_Key = this.Key
    End Property
    
    Private Property Get IHandleErrorMessage_Errors() As String
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".IHandleErrorMessage_Errors"
    If (this.Errors.Count = 0) Then Exit Property
    '==================================================================
    1   Dim Keys As Variant = this.Errors.Keys
    2   If IsObject(Keys(0)) Then
            Dim Key As Variant
    3       For Each Key In Keys
    4           IHandleErrorMessage_Errors = IHandleErrorMessage_Errors & vbLf & vbLf & CType(Of IHandleErrorMessage)(this.Errors(Key)).Errors
            Next
        Else
            Dim Error As ValidationError
    5       For Each Error In this.Errors.Items()
    6           IHandleErrorMessage_Errors = IHandleErrorMessage_Errors & vbLf & Error.PropertyName & " - " & Error.Message
            Next
        End If
    7   IHandleErrorMessage_Errors = TrimEx(IHandleErrorMessage_Errors)
        Erase Keys
        Exit Property
    '==================================================================
    ERR_:
        HandleError myName
    End Property
    
    '*************** INTERFACE ***************
    Private Sub INotifyValidationChanged_RegisterHandler(ByVal Handler As IHandleValidationChanged)
        this.Handlers.Add Handler
        If (this.Errors.Count > 0) Then Handler.OnInvalid Me
    End Sub

    Private Sub IHandleValidationChanged_OnInvalid(ByVal Handler As IHandleErrorMessage)
        If Not this.Errors.Exists(Handler.Key) Then
            this.Errors.Add Handler, Handler.Key
            If (this.Errors.Count = 1) Then NotifyInvalidStatusChange this.Handlers, Me
        End If
    End Sub

    Private Sub IHandleValidationChanged_OnValid(ByVal Handler As IHandleErrorMessage)
    '---------------------------------------
    If this.Errors Is Nothing Then Exit Sub
    '---------------------------------------
        If this.Errors.Exists(Handler.Key) Then
            this.Errors.Remove Handler.Key
            If (this.Errors.Count = 0) Then NotifyValidStatusChange this.Handlers, Me
        End If
    End Sub
    
    Public Sub UpdateErrorProperty(ByVal SourceProperty As String, ByVal ErrorProperty As String)
        If Not this.Errors.Exists(SourceProperty) Then Exit Sub
        this.Errors(SourceProperty).PropertyName = ErrorProperty
    End Sub
    
    '**************** METHODS ****************
    Public Sub ClearAll()
        If (this.Errors.Count > 0) Then
            this.Cleared = True
            NotifyValidStatusChange this.Handlers, Me
        End If
    End Sub
    
    Public Sub RestoreAll()
        If (this.Errors.Count > 0) Then
            this.Cleared = False
            NotifyInvalidStatusChange this.Handlers, Me
        End If
    End Sub
End Class
[PredeclaredId(True)]
Class ServiceProvider
Option Explicit
Private Const myClass = "ServiceProvider"

    Public Enum ServiceScope
        SINGLETON
        TRANSIENT
        SCOPED
    End Enum

    Private Services As Collection
    Private Singletons As Collection
    
    '****************** NEW ******************
    Public Sub Startup()
        Set Services = New Collection
        Set Singletons = New Collection
        RegisterServices
    End Sub
    Public Sub Shutdown()
        Set Services = Nothing
        Set Singletons = Nothing
    End Sub

    '**************** METHODS ****************
    [Description("Add services we develop for this application in the DI container (DIS class)")]
    Private Sub RegisterServices()
        Dim f As IServiceFactory
        Dim i As String, c As String
        Dim s As ServiceScope = ServiceScope.TRANSIENT
        i = "ReadWriteStrategy": c = "ReadWrite": Set f = New ReadWriteStrategyFactory
        Register f, i, c & "String"
        Register f, i, c & "Long"
        Register f, i, c & "Boolean"
        Register f, i, c & "Date"
        Register f, i, c & "StringEx", Scope:=s
        Register f, i, c & "LongEx", Scope:=s
        Register f, i, c & "BooleanEx", Scope:=s
        Register f, i, c & "DateEx", Scope:=s
        Register f, i, c & "Source"
    '   -----------------------------------------
        i = "KeyFilter": Set f = New KeyFilterFactory
        Register f, i, i & "Alpha"
        Register f, i, i & "UpperAlpha"
        Register f, i, i & "Numeric"
        Register f, i, i & "AlphaNumeric"
        Register f, i, i & "UpperAlphaNumeric"
        Register f, i, i & "UpperCase"
        Register f, i, i & "LowerCase"
        Register f, i, i & "Country"
        Register f, i, i & "Address"
        Register f, i, i & "Location"
        Register f, i, i & "PostalCode"
        Register f, i, i & "ZipCode"
        Register f, i, i & "SupplierName"
    '   -----------------------------------------
        i = "ValueValidator": c = "ValidateRequired": Set f = New ValidateRequiredFactory
        Register f, i, c & "String"
        Register f, i, c & "Long"
        Register f, i, c & "Boolean"
        Register f, i, c & "Date"
        Register f, i, c & "SupplierNumber"
        Register f, i, c & "TaxpayerID"
        Register f, i, c & "RoutingNumber"
    '   -----------------------------------------
        i = "Command": Set f = New CommandFactory
        Register f, i, "WarningBadge" & i
        Register f, i, "ConfirmSiteChange" & i
    '   -----------------------------------------
        i = "Comparer": c = "Compare": Set f = New CompareFactory
        Register f, i, c & "Strings"
        Register f, i, c & "Values"
    End Sub
    
    Private Sub Register(Factory As IServiceFactory, Interface As String, ClassName As String, Optional Constructor As Variant = Empty, Optional Scope As ServiceScope = ServiceScope.SINGLETON)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".Register"
    '==================================================================
        Services.Add New ServiceModel(ClassName, "I" & Interface, Factory, Constructor, Scope), ClassName
        Exit Sub
    '==================================================================
    ERR_:
        HandleError(myName)
    End Sub
    
    '**************** METHODS ****************
    Public Sub AddService(ByVal Service As Object, ByVal Key As String)
        Singletons.Add Service, Key
    End Sub

    Public Function GetService(ByVal ClassName As String, Optional ByVal Constructor As Variant = Empty) As Object
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".GetService"
    If (ClassName = vbNS) Then Exit Function
    '==================================================================
        Dim Service As ServiceModel
    1   If Services.Exists(ClassName) Then
    2       Set Service = Services(ClassName)
    4       If (Service.Scope = SINGLETON) Then
    5           If (Not (Singletons.Exists(ClassName))) Then
    6               Singletons.Add Service.Factory.Create(Service.ClassName, IIf(IsEmpty(Constructor), Service.Constructor, Constructor)), ClassName
                End If
    7           Set GetService = Singletons(ClassName)
    8       ElseIf (Service.Scope = TRANSIENT) Then
    9           Set GetService = Service.Factory.Create(Service.ClassName, IIf(IsEmpty(Constructor), Service.Constructor, Constructor))
            End If
        Else
    10      If Not Singletons.Exists(ClassName) Then Throw 2016, , "The added service '" & ClassName & "' does not exist."
    11      Set GetService = Singletons(ClassName)
        End If
        Exit Function
    '==================================================================
    ERR_:
        HandleError myName
    End Function
End Class

Private Class ServiceModel
Option Explicit
Private Const myClass = "ServiceModel"
                              
    Public ClassName As String
    Public Interface As String
    Public Factory As IServiceFactory
    Public Constructor As Variant
    Public Scope As ServiceScope
    
    Sub New(ClassName As String, Interface As String, Factory As IServiceFactory, Constructor As Variant, Scope As ServiceScope)
        Me.ClassName = ClassName
        Me.Interface = Interface
        Set Me.Factory = Factory
        AssignResult Me.Constructor, Constructor
        Me.Scope = Scope
    End Sub

    Private Sub Class_Terminate()
        If IsObject(Constructor) Then Set Constructor = Nothing
        Set Factory = Nothing
    End Sub
End Class

Class ReadWriteStrategyFactory
Option Explicit
Private Const myClass = "ReadWriteStrategyFactory"

    Implements IServiceFactory
    
    Private Function IServiceFactory_Create(ByVal ClassName As String, ByVal Constructor As Variant) As Object
        Dim Key As String = Mid(ClassName, 10)
        If (IsEmpty(Constructor)) Then
            Select Case Key
                Case "String": Set IServiceFactory_Create = CType(Of IReadWriteStrategy)(New ReadWriteString)
                Case "Long": Set IServiceFactory_Create = CType(Of IReadWriteStrategy)(New ReadWriteLong)
                Case "Date": Set IServiceFactory_Create = CType(Of IReadWriteStrategy)(New ReadWriteDate)
                Case "Boolean": Set IServiceFactory_Create = CType(Of IReadWriteStrategy)(New ReadWriteBoolean)
                Case "Source": Set IServiceFactory_Create = CType(Of IReadWriteStrategy)(New ReadWriteSource)
            End Select
        Else
            Select Case Key
                Case "StringEx": Set IServiceFactory_Create = CType(Of IReadWriteStrategy)(New ReadWriteStringEx(Constructor))
                Case "LongEx": Set IServiceFactory_Create = CType(Of IReadWriteStrategy)(New ReadWriteLongEx(Constructor))
                Case "BooleanEx": Set IServiceFactory_Create = CType(Of IReadWriteStrategy)(New ReadWriteBooleanEx(Constructor))
                Case "DateEx": Set IServiceFactory_Create = CType(Of IReadWriteStrategy)(New ReadWriteDateEx(Constructor))
            End Select
        End If
    End Function
End Class

Class KeyFilterFactory
Option Explicit
Private Const myClass = "KeyFilterFactory"

    Implements IServiceFactory
    
    Private Function IServiceFactory_Create(ByVal ClassName As String, ByVal Constructor As Variant) As Object
        Select Case Mid(ClassName, 10)
            Case "Alpha": Set IServiceFactory_Create = CType(Of IKeyFilter)(New KeyFilterAlpha)
            Case "UpperAlpha": Set IServiceFactory_Create = CType(Of IKeyFilter)(New KeyFilterUpperAlpha)
            Case "Numeric": Set IServiceFactory_Create = CType(Of IKeyFilter)(New KeyFilterNumeric)
            Case "AlphaNumeric": Set IServiceFactory_Create = CType(Of IKeyFilter)(New KeyFilterAlphaNumeric)
            Case "UpperAlphaNumeric": Set IServiceFactory_Create = CType(Of IKeyFilter)(New KeyFilterUpperAlphaNumeric)
            Case "UpperCase": Set IServiceFactory_Create = CType(Of IKeyFilter)(New KeyFilterUpperCase)
            Case "LowerCase": Set IServiceFactory_Create = CType(Of IKeyFilter)(New KeyFilterLowerCase)
            Case "Country": Set IServiceFactory_Create = CType(Of IKeyFilter)(New KeyFilterCountry)
            Case "Address": Set IServiceFactory_Create = CType(Of IKeyFilter)(New KeyFilterAddress)
            Case "Location": Set IServiceFactory_Create = CType(Of IKeyFilter)(New KeyFilterLocation)
            Case "PostalCode": Set IServiceFactory_Create = CType(Of IKeyFilter)(New KeyFilterPostalCode)
            Case "ZipCode": Set IServiceFactory_Create = CType(Of IKeyFilter)(New KeyFilterZipCode)
            Case "SupplierName": Set IServiceFactory_Create = CType(Of IKeyFilter)(New KeyFilterSupplierName)
        End Select
    End Function
End Class

Class ValidateRequiredFactory
Option Explicit
Private Const myClass = "ValidateRequiredFactory"

    Implements IServiceFactory
    
    Private Function IServiceFactory_Create(ByVal ClassName As String, ByVal Constructor As Variant) As Object
        Select Case Mid(ClassName, 17)
            Case "String": Set IServiceFactory_Create = CType(Of IValueValidator)(New ValidateRequiredString)
            Case "Long": Set IServiceFactory_Create = CType(Of IValueValidator)(New ValidateRequiredLong)
            Case "Boolean": Set IServiceFactory_Create = CType(Of IValueValidator)(New ValidateRequiredBoolean(Constructor))
            Case "Date": Set IServiceFactory_Create = CType(Of IValueValidator)(New ValidateRequiredDate)
            Case "SupplierNumber": Set IServiceFactory_Create = CType(Of IValueValidator)(New ValidateRequiredSupplierNumber)
            Case "TaxpayerID": Set IServiceFactory_Create = CType(Of IValueValidator)(New ValidateRequiredTaxpayerID)
            Case "RoutingNumber": Set IServiceFactory_Create = CType(Of IValueValidator)(New ValidateRequiredRoutingNumber)
        End Select
    End Function
End Class

Class CommandFactory
Option Explicit
Private Const myClass = "CommandFactory"

    Implements IServiceFactory
    
    Private Function IServiceFactory_Create(ByVal ClassName As String, ByVal Constructor As Variant) As Object
        Select Case Left(ClassName, Len(ClassName) - 7)
            Case "WarningBadge": Set IServiceFactory_Create = CType(Of ICommand)(New WarningBadgeCommand)
            Case "ConfirmSiteChange": Set IServiceFactory_Create = CType(Of ICommand)(New ConfirmSiteChangeCommand)
        End Select
    End Function
End Class

Class CompareFactory
Option Explicit
Private Const myClass = "CompareFactory"

    Implements IServiceFactory
    
    Private Function IServiceFactory_Create(ByVal ClassName As String, ByVal Constructor As Variant) As Object
        Select Case Mid(ClassName, 8)
            Case "Strings": Set IServiceFactory_Create = CType(Of IComparer)(New CompareStrings)
            Case "Values": Set IServiceFactory_Create = CType(Of IComparer)(New CompareValues)
        End Select
    End Function
End Class
Interface IReadWriteStrategy
Option Explicit

    Function Read(ByVal Instance As Object, ByVal PropertyName As String, Value As Variant) As Boolean
    Function Write(ByVal Instance As Object, ByVal PropertyName As String, ByVal Value As Variant) As Boolean
End Interface

Class ReadWriteString
Option Explicit
Private Const myClass = "ReadWriteString"

    Implements IReadWriteStrategy
    
    Private Function IReadWriteStrategy_Read(ByVal Instance As Object, ByVal PropertyName As String, Value As Variant) As Boolean
        On Error Resume Next: Value = CStr(Nz(CallByName(Instance, PropertyName, vbGet), vbNS)): IReadWriteStrategy_Read = (Err.Number = 0): On Error GoTo 0
    End Function
    
    Private Function IReadWriteStrategy_Write(ByVal Instance As Object, ByVal PropertyName As String, ByVal Value As Variant) As Boolean
        On Error Resume Next: CallByName Instance, PropertyName, vbLet, CStr(Nz(Value, vbNS)): IReadWriteStrategy_Write = (Err.Number = 0): On Error GoTo 0
    End Function
End Class

Class ReadWriteLong
Option Explicit
Private Const myClass = "ReadWriteLong"

    Implements IReadWriteStrategy
    
    Private Function IReadWriteStrategy_Read(ByVal Instance As Object, ByVal PropertyName As String, Value As Variant) As Boolean
        On Error Resume Next: Value = CLng(Nz(CallByName(Instance, PropertyName, vbGet), 0)): IReadWriteStrategy_Read = (Err.Number = 0): On Error GoTo 0
    End Function
    
    Private Function IReadWriteStrategy_Write(ByVal Instance As Object, ByVal PropertyName As String, ByVal Value As Variant) As Boolean
        On Error Resume Next: CallByName Instance, PropertyName, vbLet, CLng(Nz(Value, 0)): IReadWriteStrategy_Write = (Err.Number = 0): On Error GoTo 0
    End Function
End Class

Class ReadWriteBoolean
Option Explicit
Private Const myClass = "ReadWriteBoolean"

    Implements IReadWriteStrategy
    
    Private Function IReadWriteStrategy_Read(ByVal Instance As Object, ByVal PropertyName As String, Value As Variant) As Boolean
        On Error Resume Next: Value = CBool(Nz(CallByName(Instance, PropertyName, vbGet), False)): IReadWriteStrategy_Read = (Err.Number = 0): On Error GoTo 0
    End Function
    
    Private Function IReadWriteStrategy_Write(ByVal Instance As Object, ByVal PropertyName As String, ByVal Value As Variant) As Boolean
        On Error Resume Next: CallByName Instance, PropertyName, vbLet, CBool(Nz(Value, False)): IReadWriteStrategy_Write = (Err.Number = 0): On Error GoTo 0
    End Function
End Class

Class ReadWriteDate
Option Explicit
Private Const myClass = "ReadWriteDate"

    Implements IReadWriteStrategy
    
    Private Function IReadWriteStrategy_Read(ByVal Instance As Object, ByVal PropertyName As String, Value As Variant) As Boolean
        On Error Resume Next: Value = CDate(Nz(CallByName(Instance, PropertyName, vbGet), DEFAULT_DATE)): IReadWriteStrategy_Read = (Err.Number = 0): On Error GoTo 0
    End Function
    
    Private Function IReadWriteStrategy_Write(ByVal Instance As Object, ByVal PropertyName As String, ByVal Value As Variant) As Boolean
        On Error Resume Next: CallByName Instance, PropertyName, vbLet, CDate(Nz(Value, DEFAULT_DATE)): IReadWriteStrategy_Write = (Err.Number = 0): On Error GoTo 0
    End Function
End Class

[COMCreatable(False)]
Class ReadWriteStringEx
Option Explicit
Private Const myClass = "ReadWriteStringEx"

    Implements IReadWriteStrategy
    
    Private Index As Long
    
    Sub New(ByVal Index As Long)
        Me.Index = Index
    End Sub
    
    Private Function IReadWriteStrategy_Read(ByVal Instance As Object, ByVal PropertyName As String, Value As Variant) As Boolean
        On Error Resume Next: Value = CStr(Nz(CallByName(Instance, PropertyName, vbGet, Index), vbNS)): IReadWriteStrategy_Read = (Err.Number = 0): On Error GoTo 0
    End Function
    
    Private Function IReadWriteStrategy_Write(ByVal Instance As Object, ByVal PropertyName As String, ByVal Value As Variant) As Boolean
        On Error Resume Next: CallByName Instance, PropertyName, vbLet, Index, CStr(Nz(Value, vbNS)): IReadWriteStrategy_Write = (Err.Number = 0): On Error GoTo 0
    End Function
End Class

[COMCreatable(False)]
Class ReadWriteDateEx
Option Explicit
Private Const myClass = "ReadWriteDateEx"

    Implements IReadWriteStrategy
    
    Private i As Long
    
    Sub New(ByVal Index As Long)
        i = Index
    End Sub
           
    Private Function IReadWriteStrategy_Read(ByVal Instance As Object, ByVal PropertyName As String, Value As Variant) As Boolean
        On Error Resume Next: Value = CDate(Nz(CallByName(Instance, PropertyName, vbGet, i), DEFAULT_DATE)): IReadWriteStrategy_Read = (Err.Number = 0): On Error GoTo 0
    End Function
    
    Private Function IReadWriteStrategy_Write(ByVal Instance As Object, ByVal PropertyName As String, ByVal Value As Variant) As Boolean
        On Error Resume Next: CallByName Instance, PropertyName, vbLet, i, CDate(Nz(Value, DEFAULT_DATE)): IReadWriteStrategy_Write = (Err.Number = 0): On Error GoTo 0
    End Function
End Class

[COMCreatable(False)]
Class ReadWriteLongEx
Option Explicit
Private Const myClass = "ReadWriteLongEx"

    Implements IReadWriteStrategy
    
    Private i As Long
    
    Sub New(ByVal Index As Long)
        i = Index
    End Sub
           
    Private Function IReadWriteStrategy_Read(ByVal Instance As Object, ByVal PropertyName As String, Value As Variant) As Boolean
        On Error Resume Next: Value = CLng(Nz(CallByName(Instance, PropertyName, vbGet, i), 0)): IReadWriteStrategy_Read = (Err.Number = 0): On Error GoTo 0
    End Function
    
    Private Function IReadWriteStrategy_Write(ByVal Instance As Object, ByVal PropertyName As String, ByVal Value As Variant) As Boolean
        On Error Resume Next: CallByName Instance, PropertyName, vbLet, i, CLng(Nz(Value, 0)): IReadWriteStrategy_Write = (Err.Number = 0): On Error GoTo 0
    End Function
End Class

[COMCreatable(False)]
Class ReadWriteBooleanEx
Option Explicit
Private Const myClass = "ReadWriteBooleanEx"

    Implements IReadWriteStrategy
    
    Private i As Long
    
    Sub New(ByVal Index As Long)
        i = Index
    End Sub
           
    Private Function IReadWriteStrategy_Read(ByVal Instance As Object, ByVal PropertyName As String, Value As Variant) As Boolean
        On Error Resume Next: Value = CBool(Nz(CallByName(Instance, PropertyName, vbGet, i), False)): IReadWriteStrategy_Read = (Err.Number = 0): On Error GoTo 0
    End Function
    
    Private Function IReadWriteStrategy_Write(ByVal Instance As Object, ByVal PropertyName As String, ByVal Value As Variant) As Boolean
        On Error Resume Next: CallByName Instance, PropertyName, vbLet, i, CBool(Nz(Value, False)): IReadWriteStrategy_Write = (Err.Number = 0): On Error GoTo 0
    End Function
End Class

Class ReadWriteSource
Option Explicit
Private Const myClass = "ReadWriteSource"

    Implements IReadWriteStrategy
    
    Private Function IReadWriteStrategy_Read(ByVal Source As Object, ByVal PropertyName As String, Value As Variant) As Boolean
        On Error Resume Next: Value = CallByName(Source, PropertyName, vbGet): IReadWriteStrategy_Read = (Err.Number = 0): On Error GoTo 0
    End Function
    
    Private Function IReadWriteStrategy_Write(ByVal Source As Object, ByVal PropertyName As String, ByVal Value As Variant) As Boolean
        On Error Resume Next: CallByName Source, PropertyName, vbLet, Value: IReadWriteStrategy_Write = (Err.Number = 0): On Error GoTo 0
    End Function
End Class
[Description("An object responsible for binding a ViewModel property path to a UI element")]
Private Class PropertyBinding
Option Explicit
Private Const myClass = "PropertyBinding"
Private Const myInterface = "I" & myClass

    Implements IHandlePropertyChanged
    
    Implements IPropertyBinding
    Implements IDisposable

    Private WithEvents ComboBoxEventSource As Access.ComboBox
    Attribute ComboBoxEventSource.VB_VarHelpID = -1
    Private WithEvents ListBoxEventSource As Access.ListBox
    Attribute ListBoxEventSource.VB_VarHelpID = -1
    
    Private Type TInternal
        Target As TObject
        Index As Long
        Manager As BindingsManager
        Mode As BindingMode
        Source As TObject
        Value As TValue
        TargetPropertyArg As Variant
        Validation As TValidationStore
        Applied As Boolean
        Valid As Boolean
    End Type

    Private this As TInternal

    '****************** NEW ******************
    Sub New(ByVal Manager As BindingsManager, Index As Long, ByVal Target As Object, ByVal SourceProperty As String, ByVal TargetProperty As String, ByVal Mode As BindingMode, ByVal Validator As IValueValidator, ByVal ErrorProperty As String, ByVal ErrorFormatter As IValidationErrorFormatter, ByVal TargetPropertyArg As Variant)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".New"
    '==================================================================
    1   this.Mode = Mode
    2   this.Valid = True
'---------------------------------------
    3   Set this.Target.Object = Target
    4   this.Target.PropertyName = TargetProperty
    5   this.TargetPropertyArg = TargetPropertyArg
        Select Case True
            Case TypeOf Target Is Access.ComboBox
    6           Set ComboBoxEventSource = Target: ComboBoxEventSource.AfterUpdate = Evented
            Case TypeOf Target Is Access.ListBox
    7           Set ListBoxEventSource = Target:  ListBoxEventSource.AfterUpdate = Evented
        End Select
'---------------------------------------
    8   this.Source.PropertyName = SourceProperty
'---------------------------------------
    9   this.Validation = CreateValidationStore(Index, SourceProperty, Validator, ErrorFormatter, ErrorProperty)
    10  Set this.Manager = Manager
'---------------------------------------
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub

    '*************** INTERFACE ***************
    Private Sub IDisposable_Dispose()
    '---------------------------------------                     
        If Not this.Validation.Validator Is Nothing Then
            Terminate this.Validation.Formatter
            Set this.Validation.Handler = Nothing
            TerminateEx this.Validation.Validator
            Set this.Validation.Error = Nothing
        End If
    '   ------------------------------------
        Set ComboBoxEventSource = Nothing
        Set ListBoxEventSource = Nothing
    '   ------------------------------------
        Set this.Manager = Nothing
        Set this.Source.Object = Nothing
        Set this.Source.ReadWriteStrategy = Nothing
        Set this.Target.Object = Nothing
        Set this.Target.ReadWriteStrategy = Nothing
    End Sub

    '*************** INTERFACE ***************
    Private Sub IHandlePropertyChanged_OnPropertyChanged(ByVal Value As Variant)
        ApplyToTarget Value
    End Sub

    '************** PROPERTIES ***************
    Private Property Set Source(ByVal RHS As Object)
        Set this.Source.Object = RHS
        If Not this.Validation.Validator Is Nothing Then Set this.Validation.Handler = CType(Of IViewModel)(RHS).Manager.Validation
        this.Applied = False
    End Property

    '*************** INTERFACE ***************
    Public Sub Apply(ByVal Source As Object)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".Apply"
    '==================================================================
    1   Set Me.Source = Source
        Select Case this.Target.PropertyName
            Case "Column"
        '       this.DefaultValue *** Remains empty to indicate that this binding does not default
    2           Select Case VarType(CallByName(Source, this.Source.PropertyName, vbGet))
                    Case vbString: this.Value.Null = vbNS
                    Case vbLong: this.Value.Null = 0
                    Case vbBoolean: this.Value.Null = False
                    Case vbDate: this.Value.Null = DEFAULT_DATE
                End Select
    3           this.Value.Default = Null
            Case "Caption"
    4           this.Value.Default = this.Target.Object.Caption: this.Value.Null = vbNS
            Case "BackColor"
    5           this.Value.Default = this.Target.Object.BackColor: this.Value.Null = this.Value.Default
        End Select
    6   ConfigureReadWriteStrategy(TypeName(this.Value.Null), this.Target.ReadWriteStrategy, this.Source.ReadWriteStrategy)
    7   If (this.Mode = OneWayToSource) Then
    8       ApplyToSource
        Else
    9       ApplyToTarget TryReadSourcePropertyValue()
        End If
        Exit Sub
    '==================================================================
    ERR_:
        Debug.Print "Error " & Err.Number & " - " & Err.Description & ". " & myClass & ": Validation failed in the " & myClass & " for the following control, binding was not applied: " & this.Target.Object.Name
    End Sub

    '**************** METHODS ****************
    Private Sub Validate(ByVal SourceValue As Variant)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".Validate"
    '==================================================================
    1   Validate_ SourceValue
    2   If Not this.Validation.Handler Is Nothing Then
    3       If Not this.Validation.Validator Is Nothing Then
    4           If this.Valid Then this.Validation.Handler.Clear this.Source.PropertyName
            End If
        End If
    5   this.Manager.OnEvaluateCanExecute
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub

    '**************** METHODS ****************
    Private Function TryReadSourcePropertyValue() As Variant
    '==================================================================
    On Error Resume Next
    Const myName = myClass & ".TryReadSourcePropertyValue"
    '==================================================================
    1   If Not this.Source.ReadWriteStrategy.Read(this.Source.Object, this.Source.PropertyName, TryReadSourcePropertyValue) Then
    2       Logger.LogDebug myName, "Failed to get the source's property 'Value' (" & TypeName(this.Target) & ": '" & this.Target.Object.Name & "'); source path: '" & this.Source.PropertyName & "'; " & Err.Description
    3       On Error GoTo 0
    4       Err.Clear
        End If
        On Error GoTo 0
    End Function
    
    [Description("Reads from the target and writes to the source")]
    Private Sub ApplyToSource()
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".ApplyToSource"
    If ((this.Mode = OneTimeBinding) Or (this.Mode = OneWayToTarget)) Then Exit Sub
    '==================================================================
        Dim TargetValue As Variant
        Dim SourceValue As Variant
    1   If Not this.Target.ReadWriteStrategy.Read(this.Target.Object, this.Target.PropertyName, TargetValue) Then
    2       Logger.LogError "[" & ToString & "] failed to read target property Value."
    3       Exit Sub
        End If
    4   Validate_ TargetValue
    5   Set Me.Source = ResolveObject(this.Source.Object, this.Source.PropertyName)
    6   If Not this.Source.ReadWriteStrategy.Read(this.Source.Object, this.Source.PropertyName, SourceValue) Then
    7       Logger.LogError "[" & ToString & "] failed to read current source property Value."
    8       Exit Sub
        End If
    9   TargetValue = Nz(TargetValue, this.Value.Null)
    10  If (TargetValue <> SourceValue) Then
    11      If Not this.Validation.Handler Is Nothing Then
    12          If Not this.Validation.Validator Is Nothing Then
    13              If this.Valid Then this.Validation.Handler.Clear this.Source.PropertyName
                End If
            End If
    14      If Not this.Source.ReadWriteStrategy.Write(this.Source.Object, this.Source.PropertyName, TargetValue) Then
    15          Debug.Print myName & ":[" & ToString & "] failed to write to source property."
                Exit Sub
            End If
    16      this.Manager.OnEvaluateCanExecute
        End If
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub

    [Description("Reads from the source and writes to the target")]
    Private Sub ApplyToTarget(ByVal SourceValue As Variant)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".ApplyToTarget"
    If ((this.Mode = OneWayToSource) Or (this.Mode = OneTimeBinding And this.Applied)) Then Exit Sub '   One-way to source and already-applied one-time binding modes do not apply to target
    '==================================================================
        Dim TargetValue As Variant
        On Error Resume Next
    1   If Not this.Source.ReadWriteStrategy.Read(this.Source.Object, this.Source.PropertyName, SourceValue) Then
    2       Debug.Print myName, "Failed to get the source's property '" & this.Target.PropertyName & "' (" & TypeName(this.Target) & ": '" & this.Target.Object.Name & "'); source path: '" & this.Source.PropertyName & "'; " & Err.Description
            On Error GoTo 0
            Err.Clear
            Exit Sub
        End If
        On Error GoTo 0
    3   Validate_ SourceValue
    4   If this.Target.ReadWriteStrategy.Read(this.Target.Object, this.Target.PropertyName, TargetValue) Then
    5       If (SourceValue = TargetValue) Then Exit Sub
    6       If Not this.Target.ReadWriteStrategy.Write(this.Target.Object, this.Target.PropertyName, SourceValue) Then
    7           Debug.Print "Failed to apply binding for target property '" & this.Target.PropertyName & "' (source path: " & this.Source.PropertyName & "), target Name: " & this.Target.Object.Name
                Err.Clear
            Else
    8           If Not this.Validation.Validator Is Nothing Then If this.Valid Then this.Validation.Handler.Clear this.Source.PropertyName
    9           this.Manager.OnEvaluateCanExecute
            End If
            On Error GoTo 0
        Else
    10      Debug.Print "Failed to get the target's property '" & this.Target.PropertyName & "' (" & TypeName(this.Target) & ": '" & this.Target.Object.Name & "'); source path: '" & this.Source.PropertyName & "'; " & Err.Description
            On Error GoTo 0
            Err.Clear
        End If
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub

    '**************** METHODS ****************
    Private Sub Validate_(ByVal TargetValue As Variant)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".Validate_"
    If this.Validation.Validator Is Nothing Then Exit Sub
    '==================================================================
    1   this.Valid = this.Validation.Validator.IsValid(TargetValue, this.Source.Object, this.Target.Object, this.Validation.Error.Message)
    2   If this.Valid Then
    3       If Not this.Validation.Formatter Is Nothing Then this.Validation.Formatter.Restore
            Exit Sub
        End If
    4   If Not this.Validation.Formatter Is Nothing Then this.Validation.Formatter.Apply this.Validation.Handler.Visible, this.Source.PropertyName, ValidationErrorMessage
    5   If Not this.Validation.Handler Is Nothing Then this.Validation.Handler.OnError this.Source.PropertyName, this.Validation.Error
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub

    Private Property Get ValidationErrorMessage() As String
        If Not this.Validation.Validator Is Nothing Then ValidationErrorMessage = this.Validation.Validator.Message
    End Property

    '**************** METHODS ****************
    Private Function ToString() As String
        ToString = "Source path '" & this.Source.PropertyName & "' (" & TypeName(this.Source) & "), target property '" & this.Target.PropertyName & "' (" & TypeName(this.Target) & ")"
    End Function

    '**************** EVENTS *****************
    Private Sub OnAfterUpdate() Handles ComboBoxEventSource.AfterUpdate, ListBoxEventSource.AfterUpdate
    On Error GoTo FAILED_
        ApplyToSource
        Exit Sub
    FAILED_:
        On Error GoTo 0
    End Sub
    
    '*************** INTERFACE ***************
    Private Property Get IPropertyBinding_IsValid() As Boolean
        IPropertyBinding_IsValid = this.Valid
    End Property
    
    Private Property Get IPropertyBinding_Target() As Object
        Set IPropertyBinding_Target = this.Target.Object
    End Property
    
    Private Property Get IPropertyBinding_TargetProperty() As String
        IPropertyBinding_TargetProperty = this.Target.PropertyName
    End Property
    
    Private Property Get IPropertyBinding_SourceProperty() As String
        IPropertyBinding_SourceProperty = this.Source.PropertyName
    End Property
    
    Private Property Get IPropertyBinding_ErrorProperty() As String
        IPropertyBinding_ErrorProperty = this.Validation.Error.PropertyName
    End Property
    Private Property Let IPropertyBinding_ErrorProperty(ByVal Value As String)
        this.Validation.Error.PropertyName = Value
    End Property
    
    Private Sub IPropertyBinding_Validate(ByVal SourceValue As Variant)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myInterface & ".Validate"
    '==================================================================
    1   Validate SourceValue
    2   If Not this.Validation.Handler Is Nothing Then
    3       If Not this.Validation.Validator Is Nothing Then
    4           If this.Valid Then this.Validation.Handler.Clear this.Source.PropertyName
            End If
        End If
    5   this.Manager.OnEvaluateCanExecute
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub
    
    Private Sub IPropertyBinding_ChangeValidator(ByVal Validator As IValueValidator)
        If Not Validator Is Nothing Then
            If Not this.Validation.Validator Is Nothing Then
                If Validator Is this.Validation.Validator Then Exit Sub
                TerminateEx this.Validation.Validator
            End If
            Set this.Validation.Validator = Validator
            Validate TryReadSourcePropertyValue()
        Else
            TerminateEx this.Validation.Validator
            this.Validation.Handler.Clear this.Source.PropertyName
        End If
    End Sub
    Private Sub IPropertyBinding_UpdateValidator(ByVal Pattern As String, ByVal Message As String)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".UpdateValidator"
    '------------------------------------------------------------------
    If this.Validation.Validator Is Nothing Then Exit Sub
    If Not TypeOf this.Validation.Validator Is ValidateRequiredPattern Then Exit Sub
    '==================================================================
    1   Dim Validator As ValidateRequiredPattern = this.Validation.Validator
    2   If Not (Validator.RegEx.Pattern = Pattern) Then
    3       Validator.RegEx.Pattern = Pattern
    4       If (Not (Message = vbNS)) Then this.Validation.Error.Message = Message
    5       If Not this.Target.Object.Locked And this.Target.Object.nabled Then Validate TryReadSourcePropertyValue()
        End If
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub
End Class
[COMCreatable(False)]
Class PageControl
Option Explicit
Private Const myClass = "PageControl"

    Implements IValidationErrorFormatter
    Implements IHandleValidationChanged
    Implements IPageControl
    Implements IDisposable

    Public Event Reposition(ByVal Size As Long)
    
    Private WithEvents ImageEventSource As Access.Image
    Attribute ImageEventSource.VB_VarHelpID = -1
    Private WithEvents LabelEventSource As Access.Label
    Attribute LabelEventSource.VB_VarHelpID = -1

    Private Type TInternal
        Parent As IHandleValidationChanged
        Page As Access.Page
        Badge As Access.Control
        TabControl As Access.TabControl
        Display As DisplayState
        InitialCaption As String
        InitialWidth As Long
        ErrorCaption As String
        ErrorWidth As Long
        ErrorApplied As Boolean
    End Type

    Private this As TInternal
    
    Sub New(ByVal Parent As IHandleValidationChanged, ByVal Page As Access.Page, ByVal Badge As Access.Control)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".New"
    '==================================================================
    1   Set this.Parent = Parent
    '------------------------------------------------------------------
    2   Set this.TabControl = Page.Parent
    3   Set this.Page = Page
    '---------------------------------------
    4   this.ErrorCaption = Page.Caption
    5   this.InitialCaption = Replace(this.ErrorCaption, Padding, vbNS)
    6   this.InitialWidth = CalculateTabWidth(this.InitialCaption)
    7   this.ErrorWidth = CalculateTabWidth(this.ErrorCaption)
    8   this.ErrorApplied = True
    '------------------------------------------------------------------
    9   If Badge Is Nothing Then Exit Sub
    10  Set this.Badge = Badge
        Select Case True
           Case TypeOf Badge Is Access.Label
    11          Set LabelEventSource = Badge: LabelEventSource.OnClick = Evented
            Case TypeOf Badge Is Access.Image
    12          Set ImageEventSource = Badge: ImageEventSource.OnClick = Evented
            Case Else
        End Select
    '---------------------------------------
    13  RemoveErrorFormatting
        Exit Sub
    '=================================================================
    ERR_:
        HandleError myName
    End Sub

    Private Sub IDisposable_Dispose()
        Set LabelEventSource = Nothing
        Set ImageEventSource = Nothing
        Set this.TabControl = Nothing
        Set this.Page = Nothing
        Set this.Badge = Nothing
        Set this.Parent = Nothing
    End Sub
    
    '*************** INTERFACE ***************
    Private Property Get IPageControl_Object() As Object
        Set IPageControl_Object = this.Page
    End Property
    
    Private Property Get IPageControl_Badge() As Object
        Set IPageControl_Badge = this.Badge
    End Property
    
    Private Property Get IPageControl_Display() As DisplayState
        IPageControl_Display = this.Display
    End Property
    Private Property Let IPageControl_Display(ByVal Value As DisplayState)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".Display"
    '==================================================================
    1   If (Not (this.Display = Value)) Then
            Select Case Value
    '           ----------------------------
                Case Default
    '           ----------------------------
    2               If (this.Display = Hidden) Then
    3                   this.Page.Visible = True
    4                   RaiseEvent Reposition(this.InitialWidth)
                    End If
    '           ----------------------------
                Case ReadOnly
    '           ----------------------------
    5               If (this.Display = Hidden) Then
    6                   this.Page.Visible = True
    7                   RaiseEvent Reposition(this.InitialWidth)
                    ElseIf (this.Display = Default) Then
    8                   RemoveErrorFormatting
                    End If
    '           ----------------------------
                Case Hidden
    '           ----------------------------
    9               If (this.Display = Default) Then RemoveErrorFormatting
    10              this.Page.Visible = False
    11              RaiseEvent Reposition(-this.InitialWidth)
            End Select
    12      this.Display = Value
        End If
        Exit Property
    '==================================================================
    ERR_:
        HandleError myName
    End Property
    
    Private Property Get IPageControl_Name() As String
        IPageControl_Name = this.Page.Name
    End Property

    '*************** INTERFACE ***************
    Private Sub IHandleValidationChanged_OnInvalid(ByVal Handler As IHandleErrorMessage)
        ApplyErrorFormatting
        this.Parent.OnValid(Handler)
    End Sub

    Private Sub IHandleValidationChanged_OnValid(ByVal Handler As IHandleErrorMessage)
        RemoveErrorFormatting
        this.Parent.OnInvalid(Handler)
    End Sub
    
    '*************** INTERFACE ***************
    Private Sub IValidationErrorFormatter_Apply(ByVal Formatting As Boolean, ByVal PropertyName As String, ByVal Message As String)
        ApplyErrorFormatting
    End Sub

    Private Sub IValidationErrorFormatter_Restore()
        RemoveErrorFormatting
    End Sub
    
    '**************** EVENTS *****************
    Private Sub OnClick() Handles LabelEventSource.Click, ImageEventSource.Click
        this.TabControl.Value = this.Page.PageIndex
    End Sub

    Private Sub RemoveErrorFormatting()
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".RemoveErrorFormatting"
    '------------------------------------------------------------------
    If Not this.ErrorApplied Then Exit Sub
    Debug.Assert (this.Display = Default)
    '==================================================================
    1   this.Badge.Visible = False
    2   this.Page.Caption = this.InitialCaption
    3   RaiseEvent Reposition(-AppManager.BadgePaddingWidth)
    '---------------------------------------
    4   this.ErrorApplied = False
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub

    Private Sub ApplyErrorFormatting()
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".ApplyErrorFormatting"
    '------------------------------------------------------------------
    If Not this.Page.Visible Then Exit Sub
    If this.ErrorApplied Then Exit Sub
    If Not (this.Display = Default) Then Exit Sub
    '==================================================================
        Dim Position As Long
        Dim i As Long
    1   For i = 0 To (this.Page.PageIndex - 1)
    2       Position = Position + CalculateTabWidth(this.TabControl.Pages(i).Caption)
        Next
    4   this.Badge.Left = ((this.TabControl.Left + Position + this.ErrorWidth) - BADGE_PAGE_TAB_OFFSET)
    5   this.Page.Caption = this.ErrorCaption
    '---------------------------------------
    6   this.Badge.Visible = True
    7   RaiseEvent Reposition(AppManager.BadgePaddingWidth)
    '---------------------------------------
    8   this.ErrorApplied = True
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub
End Class

[COMCreatable(False)]
Class PagesManager
Option Explicit
Private Const myClass = "PagesManager"

    Implements IHandleValidationChanged
    Implements IHandleErrorMessage
    Implements IDisposable
   
    Private WithEvents Validation As ValidationDelegate
    
    Public Items As Collection

    Private Type TInternal
        Key As String
        Errors As Collection
        Handlers As Collection
    End Type

    Private this As TInternal
    
    '****************** NEW ******************
    Sub New(ByVal ParentHandlers As Variant)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".New"
    '==================================================================
    1   this.Key = CStr(ObjPtr(Me))
    '   ------------------------------------
    2   Set Items = New Collection
    3   Set this.Errors = New Collection: this.Errors.KeyCompareMode = vbBinaryCompare
    4   Set this.Handlers = New Collection
    '   ------------------------------------
    5   Set Validation = New ValidationDelegate
    '   ------------------------------------
    6    If Not IsMissing(ParentHandlers) And Not IsEmpty(ParentHandlers) Then
            Dim Handler As Variant
    7       For Each Handler In ParentHandlers
    8           this.Handlers.Add CType(Of IHandleValidationChanged)(Handler)
            Next
        End If
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub

    '*************** INTERFACE ***************
    Private Sub IDisposable_Dispose()
        Set this.Errors = Nothing
        Set this.Handlers = Nothing
        Terminates Items
        Set Validation = Nothing
    End Sub

    '*************** INTERFACE ***************
    Public Sub Add(ByVal Page As Access.Page, Optional ByVal Badge As Access.Control)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".Add"
    '==================================================================
        Dim Item As IPageControl: Set Item = New PageControl(Validation, Page, Badge)
    2   Items.Add Item, Page.Name
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub

    '*************** INTERFACE ***************
    Private Property Get IHandleErrorMessage_Key() As String
        IHandleErrorMessage_Key = this.Key
    End Property
    
    Private Property Get IHandleErrorMessage_Errors() As String
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".Errors"
    '==================================================================
    1   Dim Keys As Variant = this.Errors.Keys
        Dim Key As Variant
    2   For Each Key In Keys
    3       IHandleErrorMessage_Errors = this.Errors(Key).Errors & vbLf & vbLf & IHandleErrorMessage_Errors
        Next
    4   IHandleErrorMessage_Errors = TrimEx(IHandleErrorMessage_Errors)
    EXIT_:
        Erase Keys
        Exit Property
    '==================================================================
    ERR_:
        HandleError myName
        Resume EXIT_
    End Property
    
    '*************** INTERFACE ***************
    Private Sub IHandleValidationChanged_OnInvalid(ByVal Handler As IHandleErrorMessage)
        If Not this.Errors.Exists(Handler.Key) Then
            this.Errors.Add Handler, Handler.Key
            If (this.Errors.Count = 1) Then NotifyInvalidStatusChange this.Handlers, Me
        End If
    End Sub

    Private Sub IHandleValidationChanged_OnValid(ByVal Handler As IHandleErrorMessage)
    '---------------------------------------
    If this.Errors Is Nothing Then Exit Sub
    '---------------------------------------
        If this.Errors.Exists(Handler.Key) Then
            this.Errors.Remove Handler.Key
            If (this.Errors.Count = 0) Then NotifyValidStatusChange this.Handlers, Me
        End If
    End Sub
    
    '**************** EVENTS *****************
    Private Sub Validation_OnValid(ByVal Handler As IHandleErrorMessage)
        IHandleValidationChanged_OnValid Handler
    End Sub
    
    Private Sub Validation_OnInvalid(ByVal Handler As IHandleErrorMessage)
        IHandleValidationChanged_OnInvalid Handler
    End Sub
End Class
Interface IHandleLookupFilter
Option Explicit
    Sub AfterUpdate()
    Sub Change()
End Interface

[COMCreatable(False)]
Class MultiFieldLookupFilter
Option Explicit

    Implements IDisposable

    Private WithEvents EventSource As Access.ComboBox

    Private Type RowSrcInfo
        HasFilterPlaceHolder As Boolean
        HasContainsFilterInPlace As Boolean
        SupportsContainsFilter As Boolean
        SqlString As String
    End Type
    
    Private Type TInternal
        RegExp As RegExp
        CustomUnfilteredRowSrc As String
        OriginalRowSrc As String
        FilteredRowSrc As String
        MinTextLength As Long
        Filter As String
        SearchFilteredRowSrc As String
        FilteringEnabled As Boolean
        ControlName As String
        FormName As String
        IsLazyLoading As Boolean
    End Type
    
    Private this As TInternal
    
    '****************** NEW ******************
    Sub New(ByVal Target As Access.ComboBox, Optional MinTextLength As Long = 1)
        Set EventSource = Target
        EventSource.OnEnter = SetEventProc(EventSource.OnEnter)
        EventSource.AfterUpdate = SetEventProc(EventSource.AfterUpdate)
        EventSource.OnChange = SetEventProc(EventSource.OnChange)
        EventSource.OnKeyUp = SetEventProc(EventSource.OnKeyUp)
        '------------------------------------------------------------------
        Set this.RegExp = New VBScript_RegExp_55.RegExp
        this.RegExp.Global = True
        this.RegExp.IgnoreCase = False
        this.RegExp.Multiline = False
        '------------------------------------------------------------------
        this.MinTextLength = MinTextLength
        '------------------------------------------------------------------
        'we set the following module level variables to assist with debugging errors
        On Error Resume Next
        this.ControlName = EventSource.Name: Debug.Assert Len(this.ControlName) > 0
        this.FormName = EventSource.Parent.Name: Debug.Assert Len(this.FormName) > 0
    End Sub
    
    '*************** INTERFACE ***************
    Private Sub IDisposable_Dispose()
        Set this.RegExp = Nothing
        Set EventSource = Nothing
    End Sub
    
    '************** PROPERTIES ***************            
    Public Property Get IsLazyLoading() As Boolean
        IsLazyLoading = this.IsLazyLoading
    End Property
    Public Property Let IsLazyLoading(ByVal Value As Boolean)
        If Value Then  'Check prerequisites
            If Len(this.CustomUnfilteredRowSrc) = 0 Then Throw "UnfilteredRowSource property must be set before enabling lazy loading"
            If this.MinTextLength <= 1 Then Throw "Lazy loading requires a MinTextLength greater than 1"
        End If
        this.IsLazyLoading = Value
    End Property

    Public Property Get UnfilteredRowSource() As String
        If Len(this.CustomUnfilteredRowSrc) > 0 Then
            UnfilteredRowSource = IIf(Len(EventSource.Text) >= this.MinTextLength, this.CustomUnfilteredRowSrc, vbNS)
        ElseIf Not GetRowSourceInfo(this.OriginalRowSrc).HasContainsFilterInPlace Then
            UnfilteredRowSource = this.OriginalRowSrc
        ElseIf Not GetRowSourceInfo(EventSource.RowSource).HasContainsFilterInPlace Then
            UnfilteredRowSource = EventSource.RowSource
        Else
            UnfilteredRowSource = FilteredRowSource(vbNS)
        End If
    End Property
    Public Property Let UnfilteredRowSource(ByVal Value As String)
        this.CustomUnfilteredRowSrc = Value
    End Property

    ' Purpose   : Sets the minimum length for a user-entered string before filtering occurs.
    ' Notes     - Set to 1 so that filtering begins as soon as the user enters text.
    '           - Set to 3 so that filtering does not happen until at least 3 characters are entered.
    '           - If performance is slow, the MinTextLength may be increased so that fewer results are returned and filtering does not happen as frequently.
    Public Property Get MinTextLength() As Long
        MinTextLength = this.MinTextLength
    End Property
    Public Property Let MinTextLength(ByVal Value As Long)
        this.MinTextLength = Value
    End Property
                 
    '************** PROPERTIES ***************
    Private Property Get FilteredRowSource(Text As String) As String
        Dim rsi As RowSrcInfo = GetRowSourceInfo(IIf(Len(this.CustomUnfilteredRowSrc) > 0, this.CustomUnfilteredRowSrc, EventSource.RowSource))
        Debug.Assert rsi.SupportsContainsFilter
        FilteredRowSource = RegExReplace("('\*)[^*]*(\*')", rsi.SqlString, "$1" & Replace(Text, "'", "''") & "$2")
        FilteredRowSource = RegExReplace("(""\*)[^*]*(\*"")", FilteredRowSource, "$1" & Replace(Text, """", """""") & "$2")
    End Property
    
    '**************** EVENTS *****************
    ' Purpose   : After the user makes a selection, we restore the default Row Source so that all options are available the next time the user edits the control.
    ' Notes     - If lazy loading has been turned on, then clear out the row source when the user makes a selection.
    Private Sub EventSource_AfterUpdate()
        If Not this.FilteringEnabled Then Exit Sub
        If this.IsLazyLoading Then EventSource.RowSource = vbNS Else EventSource.RowSource = UnfilteredRowSource()
    End Sub

    ' Purpose   : As the user edits the field, the RowSource is dynamically updated to show the matching records.
    Private Sub EventSource_Change()
        If Not this.FilteringEnabled Then Exit Sub
        Dim SelLength As Integer = GetSelLength()
        'If .AutoExpand is True, then some of the text in the combo box may be autocompleted; for filtering purposes, we only want to consider the user-entered text
        Dim UserEnteredText As String
        If SelLength > 0 Then
            'If user is using the up and down arrow keys to choose an option in the dropdown portion of the combo box, we should let them do that without interruption from us
            If SelLength = Len(EventSource.Text) Then Exit Sub
            If Len(EventSource.Text) > 0 Then EventSource.Dropdown
            UserEnteredText = Left(EventSource.Text, Len(EventSource.Text) - SelLength)
        Else
            UserEnteredText = EventSource.Text
        End If
        If Len(UserEnteredText) < Me.MinTextLength Then
            Dim RowSource As String = UnfilteredRowSource()
            If EventSource.RowSource <> RowSource Then EventSource.RowSource = RowSource
            Exit Sub
        End If
        Dim SelStart As Integer = EventSource.SelStart
        EventSource.RowSource = FilteredRowSource(Replace(UserEnteredText, "*", "[*]"))
        EventSource.SetFocus
        EventSource.SelStart = SelStart
        EventSource.SelLength = SelLength
        If EventSource.ListCount > 0 Then EventSource.Dropdown
    End Sub

    ' Purpose   : The RowSource may have changed due to external processing, so we do another check
    Private Sub EventSource_Enter()
        Debug.Assert EventSource.RowSourceType = "Table/Query"
        'A custom unfiltered row source may be passed to the class for improved performance with large recordsets (see notes in class header)
        this.OriginalRowSrc = IIf(Len(this.CustomUnfilteredRowSrc) > 0, this.CustomUnfilteredRowSrc, EventSource.RowSource)
        Dim rsi As RowSrcInfo = GetRowSourceInfo(this.OriginalRowSrc)
        If Not rsi.SupportsContainsFilter Then
            this.FilteringEnabled = False
            'Alert the developer but not the user
            Debug.Assert False   'Throw "RowSource does not support advanced filtering: {0}", EventSource.RowSource
        Else
            this.FilteringEnabled = True
        End If
    End Sub

    ' Handle user clearing a field by pressing the Escape key
    Private Sub EventSource_KeyUp(KeyCode As Integer, Shift As Integer)
        If Not this.FilteringEnabled Then Exit Sub
        If ((KeyCode = vbKeyEscape) And (Len(EventSource.Text) = 0)) Then EventSource_Change
    End Sub

    '**************** METHODS ****************
    ' Purpose   : Returns info about a RowSrc's "contains" filter support and its current state.
    Private Function GetRowSourceInfo(RowSource As String) As RowSrcInfo
        GetRowSourceInfo.SqlString = RowSource
        GetRowSourceInfo.HasFilterPlaceHolder = (InStr(RowSource, """**""") > 0) Or (InStr(RowSource, "'**'") > 0)
        'We will assume that if there is at least one FilterPlaceHolder, then for our purposes, we assume that there is no "contains filter" (e.g., "LIKE '*sometext*'") in place
        If Not GetRowSourceInfo.HasFilterPlaceHolder Then
            Dim OpenFilterPos As Long = InStr(RowSource, """*")
            Dim CloseFilterPos As Long
            If OpenFilterPos > 0 Then CloseFilterPos = InStr(RowSource, "*""")
            GetRowSourceInfo.HasContainsFilterInPlace = (OpenFilterPos > 0 And CloseFilterPos > OpenFilterPos)
            If Not GetRowSourceInfo.HasContainsFilterInPlace Then
                OpenFilterPos = InStr(RowSource, "'*")
                If OpenFilterPos > 0 Then CloseFilterPos = InStr(OpenFilterPos, RowSource, "*'")
                GetRowSourceInfo.HasContainsFilterInPlace = (OpenFilterPos > 0 And CloseFilterPos > OpenFilterPos)
            End If
        End If
        GetRowSourceInfo.SupportsContainsFilter = (GetRowSourceInfo.HasFilterPlaceHolder Or GetRowSourceInfo.HasContainsFilterInPlace)
        If Not GetRowSourceInfo.SupportsContainsFilter Then 'Allow for RowSource's that are the names of query definitions
            On Error Resume Next
            Dim QrySql As String = CurrentDb.QueryDefs(RowSource).SQL
            On Error GoTo 0
            If Len(QrySql) > 0 Then GetRowSourceInfo = GetRowSourceInfo(QrySql)
        End If
    End Function

    'Avoids error 2185 "Can't reference prop unless the EventSource has the focus"
    Private Function GetSelLength() As Integer
    On Error Resume Next
        GetSelLength = EventSource.SelLength
    End Function
    
    ' Purpose   : Attempts to replace text in the TextToSearch with text and back references from the ReplacePattern for any matches found using SearchPattern.
    ' Notes     - If no matches are found, TextToSearch is returned unaltered. To get specific info from a string, use RegExExtract instead.
    Private Function RegExReplace(SearchPattern As String, TextToSearch As String, ReplacePattern As String) As String
        this.RegExp.Pattern = SearchPattern
        RegExReplace = this.RegExp.Replace(TextToSearch, ReplacePattern)
    End Function
End Class

[COMCreatable(False)]
[Description("Implements features to increase the effective target size of a combo box control")]
Class ComboTargetSizeBoost
Option Explicit

    Implements IDisposable

    Private WithEvents EventSource As Access.ComboBox
    
    Private FirstVisibleColumn As Integer

    '****************** NEW ******************
    Sub New(ByVal Target As Access.ComboBox)
        Set EventSource = Target
        EventSource.OnEnter = SetEventProc(EventSource.OnEnter)
        EventSource.OnMouseUp = SetEventProc(EventSource.OnMouseUp, "=EnterCombo(*)") 'Allow replacement of old references to the EnterCombo function
        If EventSource.OnKeyUp Like "=EnterCombo(*)" Then EventSource.OnKeyUp = vbNS 'Remove old references to the EnterCombo function
        FirstVisibleColumn = ResolveFirstVisibleColumn(EventSource.ColumnWidths)
    End Sub

    '*************** INTERFACE ***************
    Private Sub IDisposable_Dispose()
        Set EventSource = Nothing
    End Sub
           
    '**************** EVENTS *****************
    Private Sub EventSource_Enter()
    On Error GoTo ERR_
        With EventSource
            If Nz(.Column(FirstVisibleColumn)) = vbNS Then
                .Dropdown
            Else ' We need to check the current selection length, otherwise the control does not work as expected when the user clicks directly on the triangular dropdown symbol
                If .SelLength = 0 And .SelStart > 0 And Nz(.Column(FirstVisibleColumn)) <> vbNS Then
                    .SelStart = 0
                    .SelLength = Len(Nz(.Column(FirstVisibleColumn)))
                End If
            End If
        End With
    EXIT_:
        Exit Sub
    ERR_:
        'if there is no record selected an error will be generated (happens if control is in form header/footer and AllowAdditions is set to false and the form is filtered so there are no records)
        'there is no need to fill up the error log with these errors, so we won't record it
        If Err.Number <> 2185 Then
            'Replace with your own error logging function:
            'LogError Err.Number, Err.Description, "EnterCombo", cmb.Name, False
        End If
        Resume EXIT_
    End Sub
    
    Private Sub EventSource_OnMouseUp(Button As Integer, Shift As Integer, X As Single, Y As Single)
        If (Button = acLeftButton) Then EventSource_Enter
    End Sub

    '**************** METHODS ****************
    Private Function ResolveFirstVisibleColumn(ColumnWidths As String) As Integer
        If Len(ColumnWidths) = 0 Then Exit Function
        Dim Cols As Variant = Split(ColumnWidths, ";")
        Dim i As Integer
        For i = 0 To UBound(Cols)
            Dim ColWidth As String = CStr(Cols(i))
            If Len(ColWidth) = 0 Then ResolveFirstVisibleColumn = i: Exit Function  'Blank column values get an automatic (non-zero) width
            If Val(ColWidth) <> 0 Then ResolveFirstVisibleColumn = i: Exit Function 'The first non-zero column width is the first visible column
        Next
    End Function
End Class

[COMCreatable(False)]
Class LazyLoadingLookup
Option Explicit
                             
    Implements IHandleLookupFilter
    
    Implements INotifyLookupFilter
    Implements ILookupFilter
    Implements IDisposable
    
    Private WithEvents EventSource As Access.ComboBox
    
    Private Type TInternal
        Query As TQueryStore
        LoadLen As Integer
        NoRecords As Boolean
        LastMatch As String
        Selected As DAO.Recordset
    End Type
    
    Private this As TInternal

    Sub New(ByVal Target As Access.ComboBox, Query As TQueryStore, ByVal LoadLength As Integer)
        Set EventSource = Target: EventSource.OnKeyUp = Evented
        this.Query = Query
        this.LoadLen = IIf(LoadLength <= 1, 3, LoadLength)
    End Sub
    
    Private Sub IDisposable_Dispose()
        Erase this.Query.Match.Like
        Set EventSource = Nothing
        Set this.Selected = Nothing
    End Sub
    
    Private Sub IHandleLookupFilter_AfterUpdate()
        Set this.Selected = Nothing
    '   Has a item in the recordset been selected? A 'ListIndex' of -1 indicates that a recordset item has not been selected
        If EventSource.ListIndex > -1 Then Set this.Selected = EventSource.Recordset.Clone
        EventSource.RowSource = vbNS
    End Sub

    [Description("As the user edits the field, the RowSource is dynamically updated to show the matching records.")]
    Private Sub IHandleLookupFilter_Change()
        If this.NoRecords Then
            If EventSource.Text Like this.LastMatch & "*" And EventSource.Text <> this.LastMatch Then Exit Sub
            this.NoRecords = False
        End If
        Dim SelLength As Integer = GetSelLength()
        Dim UserEnteredText As String
        If SelLength > 0 Then
            If SelLength = Len(EventSource.Text) Then Exit Sub
            If Len(EventSource.Text) > 0 Then EventSource.Dropdown
            UserEnteredText = Left(EventSource.Text, Len(EventSource.Text) - SelLength)
        Else
            UserEnteredText = EventSource.Text
        End If
        If Len(UserEnteredText) < this.LoadLen Then
            If EventSource.RowSource <> vbNS Then EventSource.RowSource = vbNS
            Exit Sub
        End If
        Dim SelStart As Integer = EventSource.SelStart
        EventSource.RowSource = "SELECT " & this.Query.Fields & " FROM [" & this.Query.Table & "] WHERE" & this.Query.Criteria & " " & Replace(this.Query.Filter.Value, "[*]", Replace(UserEnteredText, "*", "[*]")) & this.Query.OrderBy & ";"
        EventSource.SelStart = SelStart
        EventSource.SelLength = SelLength
        If EventSource.ListCount > 0 Then
            EventSource.Dropdown
            this.LastMatch = EventSource.Text
        Else
            this.NoRecords = True
            EventSource.RowSource = vbNS
        End If
    End Sub
    
    Private Sub OnChange() Handles EventSource.Change
        IHandleLookupFilter_Change
    End Sub

    '**************** EVENTS *****************
    ' Handle user clearing a field by pressing the Escape key
    Private Sub EventSource_KeyUp(KeyCode As Integer, Shift As Integer)
        If ((KeyCode = vbKeyEscape) And (Len(EventSource.Text) = 0)) Then IHandleLookupFilter_Change
    End Sub
    
    '*************** INTERFACE ***************
    Private Property Get ILookupFilter_Selected() As DAO.Recordset
        Set ILookupFilter_Selected = this.Selected
    End Property
    
    Private Property Get ILookupFilter_Fields() As String
        ILookupFilter_Fields = this.Query.Fields
    End Property
    Private Property Let ILookupFilter_Fields(ByVal Value As String)
        this.Query.Fields = Trim(Value)
    End Property
    
    Private Property Get ILookupFilter_Table() As String
        ILookupFilter_Table = this.Query.Table
    End Property
    Private Property Let ILookupFilter_Table(ByVal Value As String)
        this.Query.Table = Trim(Value)
    End Property
    
    Private Property Get ILookupFilter_Criteria() As String
        Dim Length As Long = Len(this.Query.Criteria) - 1
        If (Length <= 0) Then Exit Property
    '   Trimmed value is returned so the space needed to build the query is not included
        ILookupFilter_Criteria = Left(Trim(this.Query.Criteria), Length - 4)
    End Property
    Private Property Let ILookupFilter_Criteria(ByVal Value As String)
        this.Query.Criteria = IIf(Value = vbNS, vbNS, " " & Trim(Value) & " AND")
    End Property
    
    Private Property Get ILookupFilter_FilterOn() As String
        ILookupFilter_FilterOn = this.Query.Filter.On
    End Property
    Private Property Let ILookupFilter_FilterOn(ByVal Value As String)
        If (this.Query.Filter.On = Value) Then Exit Property
        ParseQueryStoreFilterOn this.Query, Value
    End Property
    
    Private Property Get ILookupFilter_OrderBy() As String
    '   Starts at the 9th character so that then statement ' ORDER BY ' is not included.
    '   *** Mid function does NOT raise an error if the startindex requested is larger than the length of the string ***
        ILookupFilter_OrderBy = Mid(this.Query.OrderBy, 11)
    End Property
    Private Property Let ILookupFilter_OrderBy(ByVal Value As String)
        this.Query.OrderBy = IIf(Value = vbNS, vbNS, " ORDER BY " & Value)
    End Property
    
    Private Property Get ILookupFilter_MatchTo() As MatchMethod
        ILookupFilter_MatchTo = this.Query.Match.Value
    End Property
    Private Property Let ILookupFilter_MatchTo(ByVal Value As MatchMethod)
        If (this.Query.Match.Value = Value) Then Exit Property
        Erase this.Query.Match.Like
        ParseQueryStoreMatch this.Query, Value
    End Property
    
    '*************** INTERFACE ***************
    Private Sub INotifyLookupFilter_Register(ByVal EventName As String)
        CallByName EventSource, EventName, vbLet, Evented
    End Sub
    Private Sub INotifyLookupFilter_Unregister(ByVal EventName As String)
        CallByName EventSource, vbLet, vbNS
    End Sub
    
    '**************** METHODS ****************
    'Avoids error 2185 "Can't reference prop unless the EventSource has the focus"
    Private Function GetSelLength() As Integer
    On Error Resume Next
        GetSelLength = EventSource.SelLength
    End Function
End Class

Module LibLookupFilters
Option Explicit

    Public Type TFilter
        On As String
        Filters As String
        Value As String
    End Type

    Public Type TMatchMethod
        Value As MatchMethod
        Like() As String
    End Type

    Public Type TQueryStore
        Fields As String
        Table As String
        Criteria As String
        Filter As TFilter
        OrderBy As String
        Match As TMatchMethod
    End Type
    
    Public Function CreateQueryStore(ByVal Fields As String, ByVal Table As String, ByVal FilterOn As String, Optional ByVal MatchTo As MatchMethod = AnywhereInField, Optional ByVal Criteria As String, Optional ByVal OrderBy As String) As TQueryStore
        CreateQueryStore.Fields = Fields
        CreateQueryStore.Table = Table
        ParseQueryStoreMatch CreateQueryStore, MatchTo
        ParseQueryStoreFilterOn CreateQueryStore, FilterOn
        CreateQueryStore.Criteria = IIf(Criteria = vbNS, vbNS, " " & Trim(Criteria) & " AND")
        CreateQueryStore.OrderBy = IIf(OrderBy = vbNS, vbNS, " ORDER BY " & OrderBy)
    End Function
    
    Public Sub ParseQueryStoreFilterOn(Query As TQueryStore, ByVal Value As String)
        Query.Filter.On = Value
        If InStr(1, Value, ";") = 0 Then
            Query.Filter.Value = IIf(Value = vbNS, vbNS, "(" & Value & " Like """ & Query.Match.Like(0) & "[*]" & Query.Match.Like(1) & """)")
        Else
            Query.Filter.Value = "(" & Join(Split(Value, ";"), " OR Like """ & Query.Match.Like(0) & "[*]" & Query.Match.Like(1) & """") & ")"
        End If
    End Sub
    
    Public Sub ParseQueryStoreMatch(Query As TQueryStore, ByVal Value As MatchMethod)
        Query.Match.Like = Split(Choose(Value + 1, "*;*", ";*", "*;"), ";")
        Query.Match.Value = Value
        ParseQueryStoreFilterOn Query, Query.Filter.On
    End Sub
End Module
Module LibMVVM
Option Explicit
Private Const myModule = "LibMVVM"

    Public Enum EnumIncrementType
        StandardType    ' 0,1,2
        BitwiseType
        CustomType
    End Enum

    Public Const Padding = " "
    Public Const BadgePadding = Padding & Padding & Padding & Padding & Padding & Padding & Padding

    '**************** METHODS ****************
    [DllExport]
    Public Sub Terminate(Instance As IDisposable)
        If Instance Is Nothing Then Exit Sub
        Instance.Dispose
        Set Instance = Nothing
    End Sub

    Public Sub TerminateEx(Instance As Object)
        If Instance Is Nothing Then Exit Sub
        If TypeOf Instance Is IDisposable Then Terminate Instance Else Set Instance = Nothing
    End Sub

    Public Sub Terminates(Instance As Object)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myModule & ".Terminates"
    '==================================================================
        Dim o As IDisposable
        If Not Instance Is Nothing Then
            If Instance.Count > 0 Then
                While Instance.Count > 0
                    Set o = Instance(1)
                    Instance.Remove 1
                    o.Dispose
                    Set o = Nothing
                Wend
            End If
        End If
    EXIT_:
        Set Instance = Nothing
        Exit Sub
    '==================================================================
    ERR_:
        Select Case Err
            Case 91 'Collection empty
                Resume EXIT_
            Case Else
                Logger.LogError(myName)
                Resume EXIT_
        End Select
        Resume 0    '.FOR TROUBLESHOOTING
    End Sub

    [Description("Like Terminates but for nested collections/dictionaries")]
    Public Sub TerminatesEx(Instance As Object)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myModule & ".TerminatesEx"
    '==================================================================
        Dim o As Object
        If Not Instance Is Nothing Then
            If Instance.Count > 0 Then
                While Instance.Count > 0
                    Set o = Instance(1)
                    Instance.Remove 1
                    Terminates o
                Wend
            End If
        End If
    EXIT_:
        Set Instance = Nothing
        Exit Sub
    '==================================================================
    ERR_:
        Select Case Err
            Case 91 'Collection empty
                Resume EXIT_
            Case Else
                Logger.LogError(myName)
                Resume EXIT_
        End Select
        Resume 0    '.FOR TROUBLESHOOTING
    End Sub

    '**************** METHODS ****************
    [Description("Resets the given properties to their default values")]
    Public Sub Clear(ByVal ViewModel As Object, ByVal Manager As IViewModelManager, ParamArray Properties() As Variant)
    '==================================================================
    Const myName = myModule & ".Clear"
    '==================================================================
        Dim Item As Variant
        Manager.PauseEvaluation myName
        For Each Item In Properties
            CallByName ViewModel, Item, vbLet, DefaultValue(ViewModel, Item)
        Next
        Manager.ResumeEvaluation myName, ViewModel
    End Sub

    Private Function DefaultValue(ByVal Model As Object, ByVal PropertyName As Variant) As Variant
        Select Case VarType(CallByName(Model, PropertyName, vbGet))
            Case vbString: DefaultValue = vbNS
            Case vbBoolean: DefaultValue = False
            Case vbLong, vbInteger: DefaultValue = 0
            Case vbVariant: DefaultValue = Empty
            Case vbObject: Set DefaultValue = Nothing
        End Select
    End Function

    '@Parameters        Var - Strings Or Key-Value Pairs
    [DllExport]
    Public Function CreateEnumerationConverter(ByVal IncrementType As EnumIncrementType, ParamArray StringsOrKeyValuePairs() As Variant) As IValueConverter
    '==================================================================
    Const myName = myModule & ".CreateEnumerationConverter"
    '==================================================================
        Dim Conversions As Collection = New Collection
        Conversions.Add vbNS, "0"
        Conversions.Add "0", vbNS
    '---------------------------------------
        Dim Key As Long
        Dim i As Long
        Select Case IncrementType
            Case EnumIncrementType.StandardType
                For i = 0 To UBound(StringsOrKeyValuePairs)
                    Key = i + 1
                    Conversions.Add StringsOrKeyValuePairs(i), CStr(Key)
                    Conversions.Add Key, StringsOrKeyValuePairs(i)
                Next
            Case EnumIncrementType.BitwiseType
                Dim Bitwises As Variant
                Bitwises = Array(&H1, &H2, &H4, &H8, &H10, &H20, &H40, &H80, &H100, &H200, &H400, &H800, &H1000, &H2000, &H4000, &H8000, &H10000, &H20000, &H40000, &H80000, &H100000, &H200000, &H400000, &H800000, &H1000000, &H2000000, &H4000000, &H8000000, &H10000000, &H20000000, &H40000000, &H80000000)
                For i = 0 To UBound(StringsOrKeyValuePairs)
                    Conversions.Add StringsOrKeyValuePairs(i), CStr(Bitwises(i))
                    Conversions.Add Bitwises(i), StringsOrKeyValuePairs(i)
                Next
            Case EnumIncrementType.CustomType
                For i = 0 To UBound(StringsOrKeyValuePairs) Step 2
                    Key = i + 1
                    Conversions.Add StringsOrKeyValuePairs(Key), CStr(StringsOrKeyValuePairs(i))
                    Conversions.Add StringsOrKeyValuePairs(i), StringsOrKeyValuePairs(Key)
                Next
        End Select
        Set CreateEnumerationConverter = New EnumerationConverter(Conversions)
        Exit Function
    '==================================================================
    ERR_:
        Set Conversions = Nothing
        Logger.LogError myName
    End Function
    
    Private Sub UpdateViewState(ByVal Controls As Variant, ByVal Value As DisplayState)
        Dim Control As Variant
        For Each Control In Controls
            Control.State = Value
        Next
    End Sub
    
    Public Sub NotifyValidStatusChange(ByVal Handlers As Collection, ByVal RHS As IHandleErrorMessage)
        Dim Handler As IHandleValidationChanged
        For Each Handler In Handlers
            Handler.OnValid RHS
        Next
    End Sub
    
    Public Sub NotifyInvalidStatusChange(ByVal Handlers As Collection, ByVal RHS As IHandleErrorMessage)
        Dim Handler As IHandleValidationChanged
        For Each Handler In Handlers
            Handler.OnInvalid RHS
        Next
    End Sub
                
    Public Function ConfigureSelector(ByVal Control As Object, ByVal RowSource As String, ByVal LimitToList As Boolean) As Object
        Control.RowSource = RowSource
        Control.LimitToList = LimitToList
        Set ConfigureSelector = Control
    End Function
End Module
Interface IDisplayStateFormatter
Option Explicit
    [Description("ReadOnly --> Default")]
    Sub Apply10()
    [Description("Disabled --> Default")]
    Sub Apply20()
    [Description("Hidden --> Default")]
    Sub Apply30()
    [Description("Default --> ReadOnly")]
    Sub Apply01()
    [Description("Disabled --> ReadOnly")]
    Sub Apply21()
    [Description("Hidden --> ReadOnly")]
    Sub Apply31()
    [Description("Default --> Disabled")]
    Sub Apply02()
    [Description("ReadOnly --> Disabled")]
    Sub Apply12()
    [Description("Hidden --> Disabled")]
    Sub Apply32()
    [Description("Default -- > Hidden")]
    Sub Apply03()
    [Description("ReadOnly -- > Hidden")]
    Sub Apply13()
    [Description("Disable -- > Hidden")]
    Sub Apply23()
End Interface

Interface IOptionDisplayStateFormatter Extends IDisplayStateFormatter
Option Explicit
    Sub Update(ByVal Value As Long)
End Interface

[Description("An object that describes how a control changes its appearance given a validation error")]
[COMCreatable(False)]
Class DisplayStateFormatter
Option Explicit
Private Const myClass = "DisplayStateFormatter"

    Implements IValidationErrorFormatter
    Implements IDisplayStateFormatter
    Implements IDisposable

    Private this As TFormatting

    '****************** NEW ******************
    Sub New(ByVal Target As Access.Control)
        Set this.Target = Target
        Select Case True
            Case TypeOf Target Is Access.TextBox, TypeOf Target Is Access.ComboBox, TypeOf Target Is Access.ListBox: this.InitialBorderColor = Target.BorderColor
            Case TypeOf Target Is Access.CheckBox
            Case Else: Err.Raise vbObjectError, myClass & ".New", TypeName(Me) & ": Target of type '" & TypeName(Target) & "' is not currently supported."
        End Select
        this.InitialControlTipText = Target.ControlTipText
        this.InitialTabStop = Target.TabStop
        Set this.Associated = GetAssociatedLabel(Target, this)
    End Sub

    '*************** INTERFACE ***************
    Private Sub IDisposable_Dispose()
        Set this.Target = Nothing
        Set this.Associated = Nothing
        Set this.Badge = Nothing
    End Sub

    '*************** INTERFACE ***************
    Private Sub IValidationErrorFormatter_Apply(ByVal Formatting As Boolean, ByVal PropertyName As String, ByVal Message As String)
    '---------------------------------------
    If this.ErrorApplied Then Exit Sub
    If Not this.Badge Is Nothing Then If Not this.Badge.Visible Then this.Badge.Visible = True
    If Not Formatting Then Exit Sub
    '---------------------------------------
        this.Associated.ForeColor = ERROR_FORE_COLOR
        this.Target.BorderColor = ERROR_BORDER_COLOR
        If Not TypeOf this.Target Is Access.CheckBox Then this.Target.BackColor = ERROR_BACK_COLOR
        this.Target.ControlTipText = Message
        this.ErrorApplied = True
    End Sub

    Private Sub IValidationErrorFormatter_Restore()
        RestoreFormat
    End Sub

    '*************** INTERFACE ***************
    [Description("ReadOnly --> Default")]
    Private Sub IDisplayStateFormatter_Apply10()
        this.Target.Locked = False
    End Sub

    [Description("Disabled --> Default")]
    Private Sub IDisplayStateFormatter_Apply20()
        this.Target.BackShade = DEFAULT_BACK_SHADE
        If Not this.Associated Is Nothing Then this.Associated.ForeColor = this.InitialForeColor
        this.Target.Enabled = True
        this.Target.Locked = False
        this.Target.TabStop = this.InitialTabStop
    End Sub

    [Description("Hidden --> Default")]
    Private Sub IDisplayStateFormatter_Apply30()
        this.Target.Visible = True
        this.Target.TabStop = this.InitialTabStop
    End Sub

    [Description("Default --> ReadOnly")]
    Private Sub IDisplayStateFormatter_Apply01()
        this.Target.Locked = True
        RestoreFormat
    End Sub

    [Description("Disabled --> ReadOnly")]
    Private Sub IDisplayStateFormatter_Apply21()
        this.Target.BackShade = DEFAULT_BACK_SHADE
        If Not this.Associated Is Nothing Then this.Associated.ForeColor = this.InitialForeColor
        this.Target.Enabled = True
        this.Target.TabStop = this.InitialTabStop
    End Sub

    [Description("Hidden --> ReadOnly")]
    Private Sub IDisplayStateFormatter_Apply31()
        this.Target.Locked = True
        this.Target.Visible = True
        this.Target.TabStop = this.InitialTabStop
    End Sub

    [Description("Default --> Disabled")]
    Private Sub IDisplayStateFormatter_Apply02()
        RestoreFormat
        this.Target.BackShade = DISABLED_BACK_SHADE
        If Not this.Associated Is Nothing Then this.Associated.ForeColor = DISABLED_FORE_COLOR
        this.Target.Locked = True
        this.Target.Enabled = False
        this.Target.TabStop = False
    End Sub

    [Description("ReadOnly --> Disabled")]
    Private Sub IDisplayStateFormatter_Apply12()
        this.Target.BackShade = DISABLED_BACK_SHADE
        If Not this.Associated Is Nothing Then this.Associated.ForeColor = DISABLED_FORE_COLOR
        this.Target.Enabled = False
        this.Target.TabStop = False
    End Sub

    [Description("Hidden --> Disabled")]
    Private Sub IDisplayStateFormatter_Apply32()
        this.Target.BackShade = DISABLED_BACK_SHADE
        If Not this.Associated Is Nothing Then this.Associated.ForeColor = DISABLED_FORE_COLOR
        this.Target.Visible = True
        this.Target.Locked = True
        this.Target.Enabled = False
    End Sub

    [Description("Default -- > Hidden")]
    Private Sub IDisplayStateFormatter_Apply03()
        this.Target.Locked = True
        this.Target.Enabled = False ' Setting the control as disabled, prevents the error that occurs when the control has focus
        this.Target.Visible = False
        this.Target.Enabled = True  ' Enabling the control here does not through an error
        this.Target.TabStop = False
        RestoreFormatting
    End Sub

    [Description("ReadOnly -- > Hidden")]
    Private Sub IDisplayStateFormatter_Apply13()
        this.Target.Enabled = False
        this.Target.Visible = False
        this.Target.Enabled = True
        this.Target.TabStop = False
    End Sub

    [Description("Disable -- > Hidden")]
    Private Sub IDisplayStateFormatter_Apply23()
        this.Target.Visible = False
        this.Target.Enabled = True
        this.Target.Locked = False
        this.Target.BackShade = DEFAULT_BACK_SHADE
        If Not this.Associated Is Nothing Then this.Associated.ForeColor = this.InitialForeColor
    End Sub

    '**************** METHODS ****************
    Private Sub RestoreFormat()
    '---------------------------------------
    If Not this.Badge Is Nothing Then If this.Badge.Visible Then this.Badge.Visible = False
    If Not this.ErrorApplied Then Exit Sub
    '---------------------------------------
        RestoreFormatting
        this.ErrorApplied = False
    End Sub

    Private Sub RestoreFormatting()
        If TypeOf this.Target Is Access.TextBox Or TypeOf this.Target Is Access.ComboBox Then this.Target.BackColor = this.InitialBackColor
        this.Target.BorderColor = this.InitialBorderColor
        If Not this.Associated Is Nothing Then this.Associated.ForeColor = this.InitialForeColor
        this.Target.ControlTipText = this.InitialControlTipText
    End Sub
End Class

[Description("An object that describes how a this.Target changes its appearance given a validation error")]
[COMCreatable(False)]
Class GroupOptionFormatter
Option Explicit
Private Const myClass = "GroupOptionFormatter"

    Implements IOptionDisplayStateFormatter
    Implements IDisposable

    Private this As TFormatting

    '****************** NEW ******************
    Sub New(ByVal Target As Object, ByVal Associated As Object)
        Set this.Target = Target
        Set this.Associated = Associated
        this.InitialForeColor = this.Associated.ForeColor
    End Sub

    '*************** INTERFACE ***************
    Private Sub IDisposable_Dispose()
        Set this.Target = Nothing
        Set this.Associated = Nothing
    End Sub

    '*************** INTERFACE ***************
    [Description("Default --> ReadOnly")]
    Private Sub IOptionDisplayStateFormatter_Apply01()
        this.Target.Locked = True
        this.Target.OnMouseMove = vbNS
    End Sub
    [Description("ReadOnly --> Default")]
    Private Sub IOptionDisplayStateFormatter_Apply10()
        this.Target.Locked = False
        this.Target.OnMouseMove = USE_HAND_MACRO
    End Sub

    [Description("Default --> Disabled")]
    Private Sub IOptionDisplayStateFormatter_Apply02()
        this.Associated.ForeColor = DISABLED_FORE_COLOR
        this.Target.Locked = True
        this.Target.Enabled = False
    End Sub
    [Description("Disabled --> Default")]
    Private Sub IOptionDisplayStateFormatter_Apply20()
        this.Associated.ForeColor = this.InitialForeColor
        this.Target.Enabled = True
        this.Target.Locked = False
    End Sub

    [Description("Default -- > Hidden")]
    Private Sub IOptionDisplayStateFormatter_Apply03()
        this.Target.Locked = True
        this.Target.Enabled = False
        this.Target.Visible = False
    End Sub
    [Description("Hidden --> Default")]
    Private Sub IOptionDisplayStateFormatter_Apply30()
        this.Target.Enabled = True
        this.Target.Locked = False
        this.Target.Visible = True
    End Sub
           
    [Description("ReadOnly --> Disabled")]
    Private Sub IOptionDisplayStateFormatter_Apply12()
        this.Associated.ForeColor = DISABLED_FORE_COLOR
        this.Target.OnMouseMove = USE_HAND_MACRO
        this.Target.Enabled = False
    End Sub
    [Description("Disabled --> ReadOnly")]
    Private Sub IOptionDisplayStateFormatter_Apply21()
        this.Associated.ForeColor = this.InitialForeColor
        this.Target.OnMouseMove = vbNS
        this.Target.Enabled = True
    End Sub

    [Description("ReadOnly -- > Hidden")]
    Private Sub IOptionDisplayStateFormatter_Apply13()
        this.Target.Enabled = False
        this.Target.Visible = False
        this.Target.OnMouseMove = USE_HAND_MACRO
    End Sub
    [Description("Hidden --> ReadOnly")]
    Private Sub IOptionDisplayStateFormatter_Apply31()
        this.Target.Enabled = True
        this.Target.OnMouseMove = vbNS
        this.Target.Visible = True
    End Sub
    
    [Description("Disabled -- > Hidden")]
    Private Sub IOptionDisplayStateFormatter_Apply23()
        this.Target.Visible = False
        this.Associated.ForeColor = this.InitialForeColor
    End Sub
    [Description("Hidden --> Disabled")]
    Private Sub IOptionDisplayStateFormatter_Apply32()
        this.Associated.ForeColor = DISABLED_FORE_COLOR
        this.Target.Visible = True
    End Sub
    
    Private Sub IOptionDisplayStateFormatter_Update(ByVal Value As Long)
        Dim ForeColor As Long = IIf(this.Target.OptionValue = Value, vbBlack, Colors.OptionUnselectedForeColor)
        If Not (this.Associated.ForeColor = ForeColor) Then this.Associated.ForeColor = ForeColor
    End Sub
End Class

[Description("An object that describes how a control changes its appearance given a validation error")]
[COMCreatable(False)]
Class OptionGroupFormatter
Option Explicit
Private Const myClass = "OptionGroupFormatter"

    Implements IValidationErrorFormatter
    Implements IDisplayStateFormatter
    Implements IDisposable
    
    Private Type TOptionControl
        Object As Object
        Associated As Object
    End Type

    Private Type TOptionControls
        Controls() As TOptionControl
        UB As Long
        InitialForeColor As Long
    End Type

    Private Options As TOptionControls
    Private this As TFormatting

    '****************** NEW ******************
    Sub New(ByVal Target As Access.OptionGroup)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".New"
    '==================================================================
    1   Set this.Target = Target
    2   this.InitialBackColor = Target.BackColor
    3   this.InitialBorderColor = Target.BorderColor
    4   this.InitialControlTipText = Target.ControlTipText
    5   this.InitialTabStop = Target.TabStop
    6   Set this.Associated = GetAssociatedLabel(Target, this)
        Options.UB = -1
        Dim Control As Access.Control
    8   For Each Control In this.Target.Controls
            Dim Type As AcControlType = Control.ControlType
    9       If (Type = acOptionButton Or Type = acToggleButton Or Type = acCheckBox) Then
                Options.UB = Options.UB + 1: ReDim Preserve Options.Controls(0 To Options.UB) As TOptionControl
                Set Options.Controls(Options.UB).Object = Control
                If (Type = acToggleButton) Then Set Options.Controls(Options.UB).Associated = Control Else Set Options.Controls(Options.UB).Associated = Control.Controls(0)
            End If
        Next
    10  Options.InitialForeColor = Options.Controls(0).Associated.ForeColor
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub

    '*************** INTERFACE ***************
    Private Sub IDisposable_Dispose()
        Set this.Target = Nothing
        Set this.Associated = Nothing
        Erase Options.Controls
    End Sub

    '*************** INTERFACE ***************
    Private Sub IValidationErrorFormatter_Apply(ByVal Formatting As Boolean, ByVal PropertyName As String, ByVal Message As String)
    '---------------------------------------
    If Not Formatting Then Exit Sub
    If this.ErrorApplied Then Exit Sub
    '---------------------------------------
        this.Associated.ForeColor = ERROR_FORE_COLOR
        this.Target.BorderColor = ERROR_BORDER_COLOR
        this.Target.BackColor = ERROR_BACK_COLOR
        this.Target.ControlTipText = Message
        this.ErrorApplied = True
    End Sub

    Private Sub IValidationErrorFormatter_Restore()
        RestoreFormat
    End Sub

    '*************** INTERFACE ***************
    [Description("ReadOnly --> Default")]
    Private Sub IDisplayStateFormatter_Apply10()
        this.Target.Enabled = True
        this.Target.Locked = False
        this.Target.TabStop = this.InitialTabStop
    End Sub

    [Description("Disabled --> Default")]
    Private Sub IDisplayStateFormatter_Apply20()
        Dim i As Long
        For i = 0 To Options.UB
            Options.Controls(i).Associated.ForeColor = Options.InitialForeColor
        Next
        this.Target.BackShade = DEFAULT_BACK_SHADE
        this.Associated.ForeColor = this.InitialForeColor
        this.Target.Enabled = True
        this.Target.Locked = False
        this.Target.TabStop = this.InitialTabStop
    End Sub

    [Description("Hidden --> Default")]
    Private Sub IDisplayStateFormatter_Apply30()
        this.Target.Visible = True
        this.Target.Enabled = True
        this.Target.Locked = False
        this.Target.TabStop = this.InitialTabStop
    End Sub

    [Description("Default --> ReadOnly")]
    Private Sub IDisplayStateFormatter_Apply01()
        RestoreFormat
        Dim i As Long
        For i = 0 To Options.UB
            If Not Options.Controls(i).Object.Enabled Then
                Options.Controls(i).Object.Enabled = True
                Options.Controls(i).Object.Locked = False
                If Not (Options.Controls(i).Associated.ForeColor = Options.InitialForeColor) Then Options.Controls(i).Associated.ForeColor = Options.InitialForeColor
            ElseIf Not Options.Controls(i).Object.Visible Then
                Options.Controls(i).Object.Visible = True
            End If
        Next
        this.Target.Locked = True
        this.Target.Enabled = False
        this.Target.TabStop = False
    End Sub

    [Description("Disabled --> ReadOnly")]
    Private Sub IDisplayStateFormatter_Apply21()
        Dim i As Long
        For i = 0 To Options.UB
            Options.Controls(i).Associated.ForeColor = Options.InitialForeColor
        Next
        this.Target.BackShade = DEFAULT_BACK_SHADE
        this.Associated.ForeColor = this.InitialForeColor
    End Sub

    [Description("Hidden --> ReadOnly")]
    Private Sub IDisplayStateFormatter_Apply31()
        this.Target.Visible = True
    End Sub

    [Description("Default --> Disabled")]
    Private Sub IDisplayStateFormatter_Apply02()
        this.Target.Locked = True
        this.Target.Enabled = False
        RestoreFormat
        Dim i As Long
        For i = 0 To Options.UB
            If Not Options.Controls(i).Object.Enabled Then
                Options.Controls(i).Object.Enabled = True
                Options.Controls(i).Object.Locked = False
                If Options.Controls(i).Associated.ForeColor = Options.InitialForeColor Then Options.Controls(i).Associated.ForeColor = DISABLED_FORE_COLOR
            ElseIf Not Options.Controls(i).Object.Visible Then
                Options.Controls(i).Object.Enabled = True
                Options.Controls(i).Object.Locked = False
                Options.Controls(i).Associated.ForeColor = DISABLED_FORE_COLOR
                Options.Controls(i).Object.Visible = True
            Else
                Options.Controls(i).Associated.ForeColor = DISABLED_FORE_COLOR
            End If
        Next
        this.Target.BackShade = DISABLED_BACK_SHADE
        this.Associated.ForeColor = DISABLED_FORE_COLOR
        this.Target.TabStop = False
    End Sub

    [Description("ReadOnly --> Disabled")]
    Private Sub IDisplayStateFormatter_Apply12()
        Dim i As Long
        For i = 0 To Options.UB
            Options.Controls(i).Associated.ForeColor = DISABLED_FORE_COLOR
        Next
        this.Target.BackShade = DISABLED_BACK_SHADE
        this.Associated.ForeColor = DISABLED_FORE_COLOR
    End Sub

    [Description("Hidden --> Disabled")]
    Private Sub IDisplayStateFormatter_Apply32()
        Dim i As Long
        For i = 0 To Options.UB
            Options.Controls(i).Associated.ForeColor = DISABLED_FORE_COLOR
        Next
        this.Target.BackShade = DISABLED_BACK_SHADE
        this.Associated.ForeColor = DISABLED_FORE_COLOR
        this.Target.Visible = True
    End Sub

    [Description("Default -- > Hidden")]
    Private Sub IDisplayStateFormatter_Apply03()
        this.Target.Locked = True
        this.Target.Enabled = False
        this.Target.Visible = False
        Dim i As Long
        For i = 0 To Options.UB
            If Not Options.Controls(i).Object.Enabled Then
                Options.Controls(i).Object.Enabled = True
                Options.Controls(i).Object.Locked = False
                Options.Controls(i).Associated.ForeColor = Options.InitialForeColor
            ElseIf Not Options.Controls(i).Object.Visible Then
                Options.Controls(i).Object.Enabled = True
                Options.Controls(i).Object.Locked = False
                Options.Controls(i).Object.Visible = True
            End If
        Next
        this.Target.TabStop = False
        RestoreFormatting
    End Sub

    [Description("ReadOnly -- > Hidden")]
    Private Sub IDisplayStateFormatter_Apply13()
        this.Target.Visible = False
    End Sub

    [Description("Disable -- > Hidden")]
    Private Sub IDisplayStateFormatter_Apply23()
        this.Target.Visible = False
        Dim i As Long
        For i = 0 To Options.UB
            Options.Controls(i).Associated.ForeColor = Options.InitialForeColor
        Next
        this.Target.BackShade = DEFAULT_BACK_SHADE
        this.Associated.ForeColor = this.InitialForeColor
    End Sub

    '**************** METHODS ****************
    Private Sub RestoreFormat()
    '---------------------------------------
    If Not this.ErrorApplied Then Exit Sub
    '---------------------------------------
        RestoreFormatting
        this.ErrorApplied = False
    End Sub

    Private Sub RestoreFormatting()
        this.Target.BackColor = this.InitialBackColor
        this.Target.BorderColor = this.InitialBorderColor
        this.Associated.ForeColor = DEFAULT_FORE_COLOR
        this.Target.ControlTipText = this.InitialControlTipText
    End Sub
End Class

Module LibFormatters
Option Explicit
Private Const myModule = "LibFormatters"

    Public Type TFormatting
        Target As Object
        Associated As Object
        Badge As Object
    '---------------------------------------
        FormatBackColor As Boolean
        FormatCaption As Boolean
    '---------------------------------------
        InitialBackColor As Long
        InitialBorderColor As Long
        InitialCaption As String
        InitialControlTipText As String
        InitialForeColor As Long
        InitialTabStop As Boolean
    '---------------------------------------
        ErrorApplied As Boolean
        ErrorCaption As String
    End Type

    Public Const DEFAULT_BACK_SHADE = 100
    Public Const DEFAULT_BACK_COLOR = &HFFFFFF
    Public Const DEFAULT_BORDER_COLOR = &HBFBFBF
    Public Const DEFAULT_FORE_COLOR = &H0

    Public Const DISABLED_BACK_SHADE = 95
    Public Const DISABLED_FORE_COLOR = &HA0A0A0

    Public Const ERROR_BACK_COLOR = &HC0C0FF
    Public Const ERROR_BORDER_COLOR = &HFF
    Public Const ERROR_FORE_COLOR = &HFF
    
    Public Const FOCUSED_LABEL_FORECOLOR = 5855577
    Public Const NORMAL_LABEL_FORECOLOR = 8355711
End Module
Interface IComparer
Option Explicit

    Function IsEqual(ByVal Value1 As Variant, ByVal Value2 As Variant) As Boolean
End Interface

[COMCreatable(False)]
Class CompareStrings
Option Explicit

    Implements IComparer
    
    Private Function IComparer_IsEqual(ByVal Value1 As Variant, ByVal Value2 As Variant) As Boolean
        IComparer_IsEqual = Not CBool(StrComp(Value1, Value2, vbBinaryCompare))
    End Function
End Class

[COMCreatable(False)]
Class CompareValues
Option Explicit

    Implements IComparer
    
    Private Function IComparer_IsEqual(ByVal Value1 As Variant, ByVal Value2 As Variant) As Boolean
        IComparer_IsEqual = (Value1 = Value2)
    End Function
End Class
[Description("An object responsible for binding a ViewModel property path to a UI element")]
Interface IManagedBindings
Option Explicit

    [Description("Applies the binding")]
    Sub Apply(ByVal Source As Object)
End Interface

[COMCreatable(False)]
Class BindingsManager
Option Explicit
Private Const myClass = "BindingsManager"
                               
    Implements IHandlePropertyChanged
    Implements IBindingsManager
    Implements ICommandManager
    Implements IDisposable
    
    Public ControlBindings As Collection
    Public PropertyBindings As Collection
    Public ControlCommands As Collection
    Public EvalutionCommands As Collection
    Public ShortcutCommands As Collection
    Public BehaviorBindings As Collection
    Public Pages As PagesManager

    Private Type TInternal
        Container As Access.SubForm
        EvaluateCanExecute As String
        OnEvaluateCanExecute As Boolean
        ErrorIndex As Long
    End Type

    Private this As TInternal

    '****************** NEW ******************
    Sub New(Optional ByVal Container As Access.SubForm, Optional ByVal ParentHandlers As Variant)
        Set this.Container = Container
        If Not IsMissing(ParentHandlers) And Not IsEmpty(ParentHandlers) Then Set Pages = New PagesManager(ParentHandlers)
    '   --------------------------------
        Set ControlCommands = New Collection
        Set ShortcutCommands = New Collection
        Set EvalutionCommands = New Collection
        Set BehaviorBindings = New Collection
        Set ControlBindings = New Collection
        Set PropertyBindings = New Collection
    '   --------------------------------
        this.OnEvaluateCanExecute = True
    End Sub

    '*************** INTERFACE ***************
    Private Sub IDisposable_Dispose()
        Set this.Container = Nothing
        Terminate Pages
        Terminates ControlCommands
        Terminates ShortcutCommands
        Terminates EvalutionCommands
        Terminates BehaviorBindings
        Terminates PropertyBindings
        Terminates ControlBindings
    End Sub
    
    '*************** INTERFACE ***************
    Private Property Get IBindingsManager_Self() As IBindingsManager
        Set IBindingsManager_Self = Me
    End Property
    
    Private Sub IBindingsManager_BindControl(ByVal Target As Object, Optional ByVal Key As KeyFilter = KeyFilter.UpperOnly, Optional ByVal MaxLength As Long, Optional ByVal Validator As IValueValidator, Optional ByVal CaseSensitive As Boolean, Optional ByVal ErrorProperty As String, Optional ByVal ErrorFormatter As IValidationErrorFormatter, Optional ByVal Converter As IValueConverter, Optional ByVal Display As DisplayState = DisplayState.Default)
        IBindingsManager_BindControlFull Target, Target.Name, IIf(Key = 0, Empty, Key), MaxLength, Validator, CaseSensitive, ErrorProperty, Converter, ErrorFormatter, Display
    End Sub
                                  
    Private Sub IBindingsManager_BindControlEx(ByVal Target As Object, ByVal SourceProperty As String, Optional ByVal Key As KeyFilter = KeyFilter.UpperOnly, Optional ByVal MaxLength As Long, Optional ByVal Validator As IValueValidator, Optional ByVal CaseSensitive As Boolean, Optional ByVal ErrorProperty As String, Optional ByVal ErrorFormatter As IValidationErrorFormatter, Optional ByVal Converter As IValueConverter, Optional ByVal Display As DisplayState = DisplayState.Default)
        IBindingsManager_BindControlFull Target, SourceProperty, IIf(Key = 0, Empty, Key), MaxLength, Validator, CaseSensitive, ErrorProperty, Converter, ErrorFormatter, Display
    End Sub
    
    Private Sub IBindingsManager_BindCustomControl(ByVal Target As Object, Optional ByVal Key As IKeyFilter, Optional ByVal MaxLength As Long, Optional ByVal Validator As IValueValidator, Optional ByVal CaseSensitive As Boolean, Optional ByVal ErrorProperty As String, Optional ByVal ErrorFormatter As IValidationErrorFormatter, Optional ByVal Converter As IValueConverter, Optional ByVal Display As DisplayState = DisplayState.Default)
        IBindingsManager_BindControlFull Target, Target.Name, IIf(Key Is Nothing, Empty, Key), MaxLength, Validator, CaseSensitive, ErrorProperty, Converter, ErrorFormatter, Display
    End Sub
    
    Private Sub IBindingsManager_BindCustomControlEx(ByVal Target As Object, ByVal SourceProperty As String, Optional ByVal Key As IKeyFilter, Optional ByVal MaxLength As Long, Optional ByVal Validator As IValueValidator, Optional ByVal CaseSensitive As Boolean, Optional ByVal ErrorProperty As String, Optional ByVal ErrorFormatter As IValidationErrorFormatter, Optional ByVal Converter As IValueConverter, Optional ByVal Display As DisplayState = DisplayState.Default)
        IBindingsManager_BindControlFull Target, SourceProperty, IIf(Key Is Nothing, Empty, Key), MaxLength, Validator, CaseSensitive, ErrorProperty, Converter, ErrorFormatter, Display
    End Sub
    
    Private Sub IBindingsManager_BindReadOnly(ByVal Target As Object)
        IBindingsManager_BindControlFull Target, Target.Name, Display:=DisplayState.ReadOnly, Mode:=BindingMode.OneWayToTarget
    End Sub
    
    Private Sub IBindingsManager_BindReadOnlyEx(ByVal Target As Object, ByVal SourceProperty As String)
        IBindingsManager_BindControlFull Target, SourceProperty, Display:=DisplayState.ReadOnly, Mode:=BindingMode.OneWayToTarget
    End Sub
    
    Private Function IBindingsManager_BindLookup(ByVal Target As Object, Optional ByVal Key As KeyFilter = KeyFilter.UpperOnly, Optional ByVal MaxLength As Long, Optional ByVal Validator As IValueValidator, Optional ByVal CaseSensitive As Boolean, Optional ByVal ErrorProperty As String, Optional ByVal ErrorFormatter As IValidationErrorFormatter, Optional ByVal Converter As IValueConverter, Optional ByVal Display As DisplayState = DisplayState.Default) As ILookupFilterManager
        IBindingsManager_BindControlFull Target, Target.Name, IIf(Key = 0, Empty, Key), MaxLength, Validator, CaseSensitive, ErrorProperty, Converter, ErrorFormatter, Display, True
    End Function
    
    Private Function IBindingsManager_BindLookupEx(ByVal Target As Object, ByVal SourceProperty As String, Optional ByVal Key As IKeyFilter, Optional ByVal MaxLength As Long, Optional ByVal Validator As IValueValidator, Optional ByVal CaseSensitive As Boolean, Optional ByVal ErrorProperty As String, Optional ByVal ErrorFormatter As IValidationErrorFormatter, Optional ByVal Converter As IValueConverter, Optional ByVal Display As DisplayState = DisplayState.Default) As ILookupFilterManager
        IBindingsManager_BindControlFull Target, Target.Name, IIf(Key Is Nothing, Empty, Key), MaxLength, Validator, CaseSensitive, ErrorProperty, Converter, ErrorFormatter, Display, True
    End Function
    
    Private Sub IBindingsManager_BindControlFull(ByVal Target As Object, ByVal SourceProperty As String, Optional ByVal Key As Variant, Optional ByVal MaxLength As Long, Optional ByVal Validator As IValueValidator, Optional ByVal CaseSensitive As Boolean, Optional ByVal ErrorProperty As String, Optional ByVal ErrorFormatter As IValidationErrorFormatter, Optional ByVal Converter As IValueConverter, Optional ByVal Display As DisplayState = DisplayState.Default, Optional ByVal Mode As BindingMode = BindingMode.TwoWayBinding, Optional ByVal Lookup As Boolean)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".BindControlFull"
    '==================================================================
    1   Dim DisplayFormatter As IDisplayStateFormatter
    2   If TypeOf Target Is Access.OptionGroup Then
    3       Set DisplayFormatter = New OptionGroupFormatter(Target)
        Else
    4       Set DisplayFormatter = New DisplayStateFormatter(Target)
        End If
    5   If Not ErrorFormatter Is Nothing Then
    6       CType(Of AggregateErrorFormatter)(ErrorFormatter).Add(DisplayFormatter)
        Else
    7       Set ErrorFormatter = DisplayFormatter
        End If
    '   ------------------------------------
    8   ControlBindings.Add New ControlBinding(Me, this.ErrorIndex, Target, SourceProperty, Mode, Display, Validator, Converter, DisplayFormatter, ErrorFormatter, MaxLength, Key, Lookup, CaseSensitive, ErrorProperty), SourceProperty
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub
    
    Private Sub IBindingsManager_BindProperty(ByVal Target As Object, ByVal TargetProperty As String, Optional ByVal Validator As IValueValidator, Optional ByVal ErrorProperty As String, Optional ByVal ErrorFormatter As IValidationErrorFormatter)
        IBindingsManager_BindPropertyEx Target, Target.Name, TargetProperty, Validator, ErrorProperty, ErrorFormatter
    End Sub
    
    Private Sub IBindingsManager_BindPropertyEx(ByVal Target As Object, ByVal SourceProperty As String, ByVal TargetProperty As String, Optional ByVal Validator As IValueValidator, Optional ByVal ErrorProperty As String, Optional ByVal ErrorFormatter As IValidationErrorFormatter)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".BindProperty"
    '==================================================================
        Dim Binding As PropertyBinding
        Select Case True
            Case (TargetProperty = "BackColor" Or (TypeOf Target Is Access.Section And (TargetProperty = vbNS)))
    1            Set Binding = New PropertyBinding(Me, this.ErrorIndex, Target, SourceProperty, "BackColor", OneWayToTarget, Validator, ErrorProperty, ErrorFormatter, Empty)
            Case (TypeOf Target Is Access.Page) And ((TargetProperty = "Visible") Or (TargetProperty = vbNS))
    2           Set Binding = New PropertyBinding(Me, this.ErrorIndex, Target, SourceProperty, "Visible", OneWayToTarget, Validator, ErrorProperty, ErrorFormatter, Empty)
            Case Else
    3           Set Binding = New PropertyBinding(Me, this.ErrorIndex, Target, SourceProperty, TargetProperty, OneWayToTarget, Validator, ErrorProperty, ErrorFormatter, Empty)
        End Select
    4   PropertyBindings.Add Binding, SourceProperty
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub
    
    Private Sub IBindingsManager_BindColumn(ByVal Target As Object, Optional ByVal Index As Long = 1, Optional ByVal Validator As IValueValidator, Optional ByVal ErrorProperty As String, Optional ByVal ErrorFormatter As IValidationErrorFormatter)
        IBindingsManager_BindColumnEx Target, Target.Name, Index, Validator, ErrorProperty, ErrorFormatter
    End Sub
    
    Private Sub IBindingsManager_BindColumnEx(ByVal Target As Object, ByVal SourceProperty As String, Optional ByVal Index As Long = 1, Optional ByVal Validator As IValueValidator, Optional ByVal ErrorProperty As String, Optional ByVal ErrorFormatter As IValidationErrorFormatter)
        Debug.Assert TypeOf Target Is Access.ComboBox Or TypeOf Target Is Access.ListBox
        PropertyBindings.Add New PropertyBinding(Me, this.ErrorIndex, Target, SourceProperty, "Column", OneWayToSource, Validator, ErrorProperty, ErrorFormatter, Index), SourceProperty
    End Sub
    
    Private Sub IBindingsManager_BindCaption(ByVal Target As Object, Optional ByVal Validator As IValueValidator, Optional ByVal ErrorProperty As String, Optional ByVal ErrorFormatter As IValidationErrorFormatter)
        IBindingsManager_BindCaptionEx Target, Target.Name, Validator, ErrorProperty, ErrorFormatter
    End Sub
    
    Private Sub IBindingsManager_BindCaptionEx(ByVal Target As Object, ByVal SourceProperty As String, Optional ByVal Validator As IValueValidator, Optional ByVal ErrorProperty As String, Optional ByVal ErrorFormatter As IValidationErrorFormatter)
        PropertyBindings.Add New PropertyBinding(Me, this.ErrorIndex, Target, SourceProperty, "Caption", OneWayToTarget, Validator, ErrorProperty, ErrorFormatter, Empty), SourceProperty
    End Sub
    
    Private Sub IBindingsManager_BindVisible(ByVal Target As Object, Optional ByVal Validator As IValueValidator, Optional ByVal ErrorProperty As String, Optional ByVal ErrorFormatter As IValidationErrorFormatter)
        IBindingsManager_BindVisibileEx Target, Target.Name, Validator, ErrorProperty, ErrorFormatter
    End Sub
    
    Private Sub IBindingsManager_BindVisibileEx(ByVal Target As Object, ByVal SourceProperty As String, Optional ByVal Validator As IValueValidator, Optional ByVal ErrorProperty As String, Optional ByVal ErrorFormatter As IValidationErrorFormatter)
        PropertyBindings.Add New PropertyBinding(Me, this.ErrorIndex, Target, SourceProperty, "Visible", OneWayToTarget, Validator, ErrorProperty, ErrorFormatter, Empty), SourceProperty
    End Sub
    
    Private Sub IBindingsManager_BindPaginationCommand(ByVal Target As Object, ByVal Previous As String, ByVal Source As Object, ByVal Focus As Object)
        ControlCommands.Add New CommandBinding(Target, New PaginationCommand(Previous, ResolveAssociatedLabel(Target), Source, Focus), "OnGotFocus"), Target.Name & ".Pagination"
    End Sub
    
    Private Sub IBindingsManager_BindSkipBlankCommand(ByVal Target As Object, ByVal Previous As Object, ByVal Focus As Object)
        ControlCommands.Add New CommandBinding(Target, New SkipBlankCommand(Previous.Name, ResolveAssociatedLabel(Target), Previous, Focus), "OnGotFocus"), Target.Name & ".SkipBlank"
    End Sub
    
    Private Sub IBindingsManager_BindSubmitCommand(ByVal Target As Object, ByVal View As IView, Optional ByVal Description As String = "Click to submit")
        EvalutionCommands.Add New CommandBinding(Target, New SubmitCommand(View, Description)), "Submit"
    End Sub
    
    Private Sub IBindingsManager_BindCancelCommand(ByVal Target As Object)
        ControlCommands.Add New CommandBinding(Target, New CancelCommand(Target), "OnUnload"), "Cancel"
    End Sub
    
    Private Sub IBindingsManager_BindRelatedCommand(ByVal Target As Object, ByVal ParentForm As Object, ByVal FindFormName As String, ByVal FilterProperty As String, ByVal RelatedField As Object)
        ControlCommands.Add New CommandBinding(Target, New RelatedCommand(ParentForm, FindFormName, FilterProperty, RelatedField)), Target.Name & ".Related"
    End Sub
    
    Private Sub IBindingsManager_BindFileCommand(ByVal File As Object, ByVal Focus As Object, ByVal Remove As Object, Optional ByVal StartingFolder As String, ByVal FileTypes As String = "All types|*.*", Optional ByVal DialogTitle As String = "Select File", Optional ByVal MultiSelect As Boolean)
    1   If (StartingFolder = vbNS) Then StartingFolder = GetCommonFolder(DocumentsFolder)
    2   ControlCommands.Add New CommandBinding(Focus, New BrowseFileCommand(File, Remove, StartingFolder, FileTypes, DialogTitle)), File.Name & ".BrowseFile"
    3   ControlCommands.Add New CommandBinding(Remove, New RemoveFileCommand(File, Focus), PropertyName:="Visible"), File.Name & ".RemoveFile"
    End Sub
    
    Private Sub IBindingsManager_BindCommand(ByVal Target As Object, ByVal Command As ICommand, Optional ByVal EventName As String = "OnClick", Optional ByVal PropertyName As String = "Enabled")
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".BindCommand"
    '==================================================================
        Select Case True
            Case TypeOf Target Is Access.Control
    1           Dim Evaluate As Boolean = TypeOf Command Is ICommandEvaluator
                If TypeOf Command Is IGenericCommand Then
    2               IIf(Evaluate, EvalutionCommands, ControlCommands).Add New CommandBinding(Target, Command, EventName, PropertyName, Evaluate)
                Else
    3               IIf(Evaluate, EvalutionCommands, ControlCommands).Add New CommandBinding(Target, Command, EventName, PropertyName, Evaluate), Replace(TypeName(Command), "Command", vbNS)
                End If
            Case TypeOf Target Is MenuBarButton
    4           ShortcutCommands.Add New CommandBinding(Target, Command, EventName, PropertyName, TypeOf Command Is ICommandEvaluator)
            Case Else
    5           Err.Raise vbObjectError
        End Select
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub
    
    Private Sub IBindingsManager_BindRowBehavior(ByVal Target As Object, ByVal Controls As Object, ParamArray Names() As Variant)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".BindRowBehavior"
    Const STANDARD_ROW_HEIGHT = 536
    '==================================================================
    1   Dim EventSource As ControlBinding = ControlBindings(Target.Name)
        Dim ControlName As Variant
    2   For Each ControlName In Names
    3       BehaviorBindings.Add New RowPositionBehavior(Controls(ControlName), EventSource, STANDARD_ROW_HEIGHT)', Target.Name & "." & Control.Name & ".Position"
        Next
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub
    
    Private Sub IBindingsManager_BindPages(ByVal Controls As Object, ByVal TabControl As Object)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".BindPages"
    '==================================================================
    1   If Pages Is Nothing Then Set Pages = New PagesManager(Empty)
    2   If (AppManager.PageTabPaddingX = 0) Then AppManager.PageTabPaddingX = CalculatePageTabPaddingX(TabControl)
    '   -----------------------------------------
        Dim Page As Access.Page
    3   For Each Page In TabControl.Pages
    4       Pages.Add Page, ResolveBadge(Controls, Page.Name)
        Next
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub
    
    Private Function ResolveBadge(ByVal Controls As Access.Controls, ByVal PageName As String) As Access.Control
        On Error Resume Next: Set ResolveBadge = Controls(Left(PageName, Len(PageName) - 4) & "Badge"): On Error GoTo 0
    End Function

    Private Sub IBindingsManager_ApplyBindings(ByVal Source As Object)
        BindBadgeBehavior
        RegisterValidation Source
        ApplyAllBindings Source
    End Sub
    
    Private Sub IBindingsManager_ApplyBindingsEx(ByVal Source As Object, ByVal Target As IPageControl, ByVal Display As DisplayState, ByVal Validator As IValueValidator)
        PropertyBindings.Add New PropertyBinding(Me, this.ErrorIndex, Target, "Display", "Display", OneWayToTarget, Validator, "Display", Target, Empty), "Display"
        ControlCommands.Add New CommandBinding(Target.Badge, ServiceProvider.GetService("WarningBadgeCommand"), "OnDblClick", "Visible", False)
        IBindingsManager_ApplyBindings Source
    End Sub

    '**************** METHODS ****************
    Public Sub OnEvaluateCanExecute()
        If this.OnEvaluateCanExecute Then
            OnEvaluateCanExecute EvalutionCommands
            OnEvaluateCanExecute ShortcutCommands
        End If
    End Sub

    '*************** INTERFACE ***************
    Private Sub ICommandManager_PauseEvaluation(ByVal Caller As String)
        If (this.EvaluateCanExecute = vbNS) Then
            this.EvaluateCanExecute = Caller
            this.OnEvaluateCanExecute = False
        End If
    End Sub

    Private Sub ICommandManager_ResumeEvaluation(ByVal Caller As String)
        If (this.EvaluateCanExecute = Caller) Then
            this.EvaluateCanExecute = vbNS
            this.OnEvaluateCanExecute = True
            OnEvaluateCanExecute EvalutionCommands
            OnEvaluateCanExecute ShortcutCommands
        End If
    End Sub
    
    Private Sub ICommandManager_EvaluateCommand(ByVal CommandName As String)
        If Not this.EvaluateCanExecute Then Exit Sub
        If Not EvalutionCommands.Exists(CommandName) Then Exit Sub
        EvalutionCommands(CommandName).OnEvaluateCanExecute
    End Sub

    Private Sub ICommandManager_EvaluateCommands()
        OnEvaluateCanExecute EvalutionCommands
    End Sub
    
    Private Sub ICommandManager_EvaluateShortcut(ByVal ShortcutName As String)
        If Not this.EvaluateCanExecute Then Exit Sub
        If Not ShortcutCommands.Exists(ShortcutName) Then Exit Sub
        ShortcutCommands(ShortcutName).OnEvaluateCanExecute
    End Sub

    Private Sub ICommandManager_EvaluateShortcuts()
        OnEvaluateCanExecute ShortcutCommands
    End Sub
    
    Private Sub ICommandManager_EvaluateAll()
        If Not this.EvaluateCanExecute Then Exit Sub
        OnEvaluateCanExecute EvalutionCommands
        OnEvaluateCanExecute ShortcutCommands
    End Sub

    '*************** INTERFACE ***************
    Private Sub IHandlePropertyChanged_OnPropertyChanged(ByVal Value As Variant)
        If this.OnEvaluateCanExecute Then OnEvaluateCanExecute EvalutionCommands
    End Sub

    '**************** METHODS ****************
    Private Sub BindBadgeBehavior()
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".BindBadgeBehavior"
    '==================================================================
    1   If Not Pages Is Nothing Then
    2       Dim Count As Long = Pages.Items.Count
    3       If (Count > 1) Then
                Dim i As Long, n As Long
    4           For i = 1 To (Count - 1)
    5               Dim Page As IPageControl: Set Page = Pages.Items(i)
    6               For n = i + 1 To Count
    7                   Dim Badge As Access.Control: Set Badge = Pages.Items(n).Badge
    8                   If Not Badge Is Nothing Then BehaviorBindings.Add New BadgeBehavior(Page, Badge)
                    Next
                Next
            End If
        End If
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub
    
    Private Sub RegisterValidation(ByVal Source As IViewModel)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".RegisterValidation"
    If Not PropertyBindings.Exists("Display") Then Exit Sub
    '==================================================================
    1   CType(Of INotifyValidationChanged)(Source.Manager.Validation).RegisterHandler(CType(Of IPropertyBinding)(PropertyBindings("Display")).Target)
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub
    
    Private Sub OnEvaluateCanExecute(ByVal CommandBindings As Collection)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".OnEvaluateCanExecute"
    '==================================================================
    1   If this.OnEvaluateCanExecute Then
            Dim Binding As CommandBinding
    2       For Each Binding In CommandBindings
    3           Binding.EvaluateCanExecute
            Next
        End If
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub

    Private Sub ApplyAllBindings(ByVal Source As Object)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".ApplyAllBindings"
    '==================================================================
    1   ApplyControlBindings Source
    2   ApplyPropertyBindings Source
    3   ApplyCommandBindings Source, ControlCommands
    4   ApplyCommandBindings Source, EvalutionCommands
    5   ApplyCommandBindings Source, ShortcutCommands
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub

    Private Sub ApplyControlBindings(ByVal Source As Object)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".ApplyControlBindings"
    '==================================================================
        Dim Control As ControlBinding
    1   For Each Control In ControlBindings
            Dim SourceProperty As String
    2       Dim Binding As IManagedObject = Control.Apply(Source, SourceProperty)
    3       If Not Binding Is Nothing Then
    4           If BehaviorBindings.Exists(SourceProperty) Then RegisterPropertyChangedHandlers Source, SourceProperty, Binding, ApplyBehaviorBindings(Source, SourceProperty)
    7           Binding.Apply Source
            End If
        Next
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub

    Private Sub RegisterPropertyChangedHandlers(ByVal Notifier As Object, ByVal SourceProperty As String, ByVal Handler As IHandlePropertyChanged, ByVal Handlers As Collection)
    1   Handlers.Add Handler, Before:=1
    2   'Notifier.RegisterHandler New AggregatePropertyChangedHandler(Handlers), SourceProperty
    End Sub

    Private Function ApplyBehaviorBindings(ByVal Source As Object, ByVal SourceProperty As String) As Collection
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".ApplyBehaviorBindings"
    '==================================================================
    1   Set ApplyBehaviorBindings = BehaviorBindings(SourceProperty)
        Dim Binding As IManagedObject
    2   For Each Binding In ApplyBehaviorBindings
    3       Binding.Apply Source
        Next
        Exit Function
    '==================================================================
    ERR_:
        HandleError myName
    End Function

    Private Sub ApplyPropertyBindings(ByVal Source As Object)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".ApplyPropertyBindings"
    '==================================================================
        Dim Binding As PropertyBinding
    1   For Each Binding In PropertyBindings
    2       Binding.Apply Source
        Next
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub
    
    Private Sub ApplyCommandBindings(ByVal Source As Object, ByVal Bindings As Collection)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".ApplyCommandBindings"
    If (Bindings.Count = 0) Then Exit Sub
    '==================================================================
        Dim Binding As CommandBinding
    1   For Each Binding In Bindings
    2       Binding.Apply Source
        Next
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub
End Class
[COMCreatable(False)]
Class BadgeBehavior
Option Explicit
Private Const myClass = "BadgeBehavior"

    Implements IDisposable

    Private WithEvents PageControlEventSource As PageControl
    Attribute PageControlEventSource.VB_VarHelpID = -1

    Private Type TInternal
        Badge As Access.Control
    End Type
    
    Private this As TInternal

    Sub New(ByVal Page As PageControl, ByVal Badge As Access.Control)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".New"
    '==================================================================
    1   Set PageControlEventSource = Page
    2   Set this.Badge = Badge
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub

    Private Sub IDisposable_Dispose()
        Set PageControlEventSource = Nothing
        Set this.Badge = Nothing
    End Sub

    Private Sub PageControlEventSource_Reposition(ByVal Size As Long)
        If this.Badge.Visible Then this.Badge.Left = this.Badge.Left + Size
    End Sub
End Class

[COMCreatable(False)]
Class RowPositionBehavior
Option Explicit
Private Const myClass = "RowPositionBehavior"

    Implements IDisposable

    Private WithEvents ControlBindingEventSource As ControlBinding
    Attribute ControlBindingEventSource.VB_VarHelpID = -1
    
    Private Type TInternal
        Adjustment As Long
        Control As Access.Control
        Controls As Object
    End Type
    
    Private this As TInternal

    '****************** NEW ******************
    Sub New(ByVal Control As Access.Control, ByVal EventSource As ControlBinding, ByVal Adjustment As Long)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".New"
    '==================================================================
    1   this.Adjustment = Adjustment
    2   Set this.Control = Control
        On Error Resume Next
    3   Set this.Controls = Control.Controls
    4   If (Err.Number <> 0) Then
    5       Set this.Controls = New Collection
    6       Err.Clear
        End If
    7   Set ControlBindingEventSource = EventSource
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub

    '*************** INTERFACE ***************
    Private Sub IDisposable_Dispose()
        Set ControlBindingEventSource = Nothing
        Set this.Controls = Nothing
        Set this.Control = Nothing
    End Sub
    
    Private Sub ControlBindingEventSource_Hidden()
        Dim Control As Object
    1   For Each Control In this.Controls
    2        Control.Top = Control.Top - this.Adjustment
        Next
    3   this.Control.Top = this.Control.Top - this.Adjustment
    End Sub
    
    Private Sub ControlBindingEventSource_Shown()
        Dim Control As Object
    1   this.Control.Top = this.Control.Top + this.Adjustment
    2   For Each Control In this.Controls
    3       Control.Top = Control.Top + this.Adjustment
        Next
    End Sub
End Class
[Description("An object responsible for binding a command to a UI element")]
[COMCreatable(False)]
Class CommandBinding
Option Explicit
Private Const myClass = "CommandBinding"

    Implements IDisposable

    Private WithEvents CheckBoxEventSource As Access.CheckBox
    Attribute CheckBoxEventSource.VB_VarHelpID = -1
    Private WithEvents ComboBoxEventSource As Access.ComboBox
    Attribute ComboBoxEventSource.VB_VarHelpID = -1
    Private WithEvents CommandButtonEventSource As Access.CommandButton
    Attribute CommandButtonEventSource.VB_VarHelpID = -1
    Private WithEvents FormEventSource As Access.Form
    Attribute FormEventSource.VB_VarHelpID = -1
    Private WithEvents ImageEventSource As Access.Image
    Attribute ImageEventSource.VB_VarHelpID = -1
    Private WithEvents LabelEventSource As Access.Label
    Attribute LabelEventSource.VB_VarHelpID = -1
    Private WithEvents ListBoxEventSource As Access.ListBox
    Attribute ListBoxEventSource.VB_VarHelpID = -1
    Private WithEvents MenuBarButtonEventSource As MenuBarButton
    Attribute MenuBarButtonEventSource.VB_VarHelpID = -1
    Private WithEvents OptionButtonEventSource As Access.OptionButton
    Attribute OptionButtonEventSource.VB_VarHelpID = -1
    Private WithEvents OptionGroupEventSource As Access.OptionGroup
    Attribute OptionGroupEventSource.VB_VarHelpID = -1
    Private WithEvents PageEventSource As Access.Page
    Attribute PageEventSource.VB_VarHelpID = -1
    Private WithEvents TabControlEventSource As Access.TabControl
    Attribute TabControlEventSource.VB_VarHelpID = -1
    Private WithEvents TextBoxEventSource As Access.TextBox
    Attribute TextBoxEventSource.VB_VarHelpID = -1
    Private WithEvents ToggleButtonEventSource As Access.ToggleButton
    Attribute ToggleButtonEventSource.VB_VarHelpID = -1
    Private WithEvents ToolBarButtonEventSource As ToolBarButton
    Attribute ToolBarButtonEventSource.VB_VarHelpID = -1
    
    Public Target As Object
    Public Command As ICommand

    Private Type TInternal
        PropertyName As String
        Source As Object
        EventName As String
        Evaluate As Boolean
        State As DisplayState
        InitialDescription As String
    End Type

    Private this As TInternal

    '****************** NEW ******************
    [Description("Creates an ICommandBinding implementation binding the specified ICommand to the specified Target")]
    Sub New(ByVal Target As Object, ByVal Command As ICommand, Optional ByVal EventName As String = "OnClick", Optional ByVal PropertyName As String = "Enabled", Optional ByVal Evaluate As Boolean)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".New"
    '==================================================================
    1   Set Me.Target = Target
    2   this.PropertyName = PropertyName
        this.EventName = EventName
        If TypeOf Target Is Access.Control Then
    3       Dim Description As String = Command.Description
    4       If (Target.ControlTipText = vbNS) Or ((EventName = "OnClick") And (Not (Description = vbNS))) Then Me.Target.ControlTipText = Description: this.InitialDescription = Description
        End If
        Select Case True
            Case TypeOf Target Is Access.CommandButton
                Set CommandButtonEventSource = Target
    5           CallByName CommandButtonEventSource, EventName, vbLet, Evented
            Case TypeOf Target Is MenuBarButton
    6           Set MenuBarButtonEventSource = Target
            Case TypeOf Target Is Access.TabControl
                Set TabControlEventSource = Target
    7           CallByName TabControlEventSource, EventName, vbLet, Evented
            Case TypeOf Target Is ToolBarButton
    8           Set ToolBarButtonEventSource = Target
            Case TypeOf Target Is Access.ComboBox
                Set ComboBoxEventSource = Target
    9           CallByName ComboBoxEventSource, EventName, vbLet, Evented
            Case TypeOf Target Is Access.Form
                Set FormEventSource = Target
    10          CallByName FormEventSource, EventName, vbLet, Evented
            Case TypeOf Target Is Access.TextBox
                Set TextBoxEventSource = Target
    11          CallByName TextBoxEventSource, EventName, vbLet, Evented
            Case TypeOf Target Is Access.Page
                Set PageEventSource = Target
    12          CallByName PageEventSource, EventName, vbLet, Evented
            Case TypeOf Target Is Access.Image
                Set ImageEventSource = Target
    13          CallByName ImageEventSource, EventName, vbLet, Evented
            Case TypeOf Target Is Access.Label
                Set LabelEventSource = Target
    14          CallByName LabelEventSource, EventName, vbLet, Evented
            Case TypeOf Target Is Access.ListBox
                Set ListBoxEventSource = Target
    15          CallByName ListBoxEventSource, EventName, vbLet, Evented
            Case TypeOf Target Is Access.ToggleButton
                Set ToggleButtonEventSource = Target
    16          CallByName ToggleButtonEventSource, EventName, vbLet, Evented
                If (EventName = "AfterUpdate") Then ToggleButtonEventSource.OnKeyPress = Evented
            Case TypeOf Target Is Access.OptionButton
                Set OptionButtonEventSource = Target
    17          CallByName OptionButtonEventSource, EventName, vbLet, Evented
                If (EventName = "OnGotFocus") Then OptionButtonEventSource.OnKeyPress = Evented
                If (EventName = "AfterUpdate") Then OptionButtonEventSource.OnKeyPress = Evented
            Case TypeOf Target Is Access.OptionGroup
                Set OptionGroupEventSource = Target
    18          CallByName OptionGroupEventSource, EventName, vbLet, Evented
            Case TypeOf Target Is Access.CheckBox
                Set CheckBoxEventSource = Target
    19          CallByName CheckBoxEventSource, EventName, vbLet, Evented
                If (EventName = "AfterUpdate") Then CheckBoxEventSource.OnKeyPress = Evented
        End Select
    20  Set Me.Command = Command
    21  this.Evaluate = Evaluate
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
    End Sub

    '*************** INTERFACE ***************
    Private Sub IDisposable_Dispose()
        Set CheckBoxEventSource = Nothing
        Set ComboBoxEventSource = Nothing
        Set CommandButtonEventSource = Nothing
        Set FormEventSource = Nothing
        Set ImageEventSource = Nothing
        Set LabelEventSource = Nothing
        Set ListBoxEventSource = Nothing
        Set MenuBarButtonEventSource = Nothing
        Set OptionButtonEventSource = Nothing
        Set OptionGroupEventSource = Nothing
        Set PageEventSource = Nothing
        Set TabControlEventSource = Nothing
        Set TextBoxEventSource = Nothing
        Set ToggleButtonEventSource = Nothing
        Set ToolBarButtonEventSource = Nothing
    '   ------------------------------------
        TerminateEx Command
        Set Target = Nothing
        Set this.Source = Nothing
    End Sub

    '**************** METHODS ****************
    Public Sub Apply(ByVal Source As Object)
        Set this.Source = Source
        EvaluateCanExecute
    End Sub
    
    Public Sub EvaluateCanExecute()
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".EvaluateCanExecute"
    '==================================================================
    1   If this.Evaluate Then CallByName Target, this.PropertyName, vbLet, Command.CanExecute(this.Source)
        Exit Sub
    ERR_:
        HandleError(myName)
    End Sub

    '**************** EVENTS *****************
    Private Sub EventHandler() Handles CheckBoxEventSource.AfterUpdate, CheckBoxEventSource.Click, CheckBoxEventSource.Enter, CheckBoxEventSource.GotFocus, CheckBoxEventSource.LostFocus, ComboBoxEventSource.AfterUpdate, ComboBoxEventSource.Enter, ComboBoxEventSource.GotFocus, ComboBoxEventSource.LostFocus, CommandButtonEventSource.Enter, CommandButtonEventSource.GotFocus, CommandButtonEventSource.LostFocus, FormEventSource.AfterInsert, FormEventSource.AfterUpdate, FormEventSource.BeforeQuery, FormEventSource.Current, FormEventSource.Query, FormEventSource.Resize, FormEventSource.SelectionChange, FormEventSource.Timer, ListBoxEventSource.AfterUpdate, ListBoxEventSource.Enter, ListBoxEventSource.GotFocus, ListBoxEventSource.LostFocus, MenuBarButtonEventSource.Click, OptionButtonEventSource.AfterUpdate, OptionButtonEventSource.Click, OptionButtonEventSource.GotFocus, OptionButtonEventSource.LostFocus, OptionGroupEventSource.AfterUpdate, OptionGroupEventSource.Click, OptionGroupEventSource.Enter, PageEventSource.Click, TabControlEventSource.Click, TabControlEventSource.Change, TextBoxEventSource.AfterUpdate, TextBoxEventSource.Enter, TextBoxEventSource.GotFocus, TextBoxEventSource.LostFocus, ToggleButtonEventSource.AfterUpdate, ToggleButtonEventSource.Click, ToggleButtonEventSource.Enter, ToggleButtonEventSource.GotFocus, ToggleButtonEventSource.LostFocus, ToolBarButtonEventSource.Click
        Command.Execute this.Source, Target
    End Sub
    
    Private Sub ClickEventHandler() Handles ComboBoxEventSource.Click, CommandButtonEventSource.Click, ImageEventSource.Click, LabelEventSource.Click, ListBoxEventSource.Click, TextBoxEventSource.Click
        If this.EventName = "OnClick" Then Command.Execute this.Source, Target
    End Sub
    
    Private Sub EventHandlerI(I1 As Integer) Handles CheckBoxEventSource.BeforeUpdate, CheckBoxEventSource.DblClick, CheckBoxEventSource.Exit, CheckBoxEventSource.KeyPress, ComboBoxEventSource.BeforeUpdate, ComboBoxEventSource.DblClick, ComboBoxEventSource.Dirty, ComboBoxEventSource.Exit, ComboBoxEventSource.KeyPress, ComboBoxEventSource.Undo, CommandButtonEventSource.DblClick, CommandButtonEventSource.Exit, CommandButtonEventSource.KeyPress, FormEventSource.AfterDelConfirm, FormEventSource.BeforeInsert, FormEventSource.BeforeUpdate, FormEventSource.Delete, FormEventSource.Dirty, FormEventSource.RecordExit, FormEventSource.Undo, FormEventSource.Unload, ImageEventSource.DblClick, LabelEventSource.DblClick, ListBoxEventSource.BeforeUpdate, ListBoxEventSource.DblClick, ListBoxEventSource.Exit, ListBoxEventSource.KeyPress, OptionButtonEventSource.BeforeUpdate, OptionButtonEventSource.DblClick, OptionButtonEventSource.Exit, OptionGroupEventSource.BeforeUpdate, OptionGroupEventSource.DblClick, OptionGroupEventSource.Exit, PageEventSource.DblClick, TabControlEventSource.DblClick, TextBoxEventSource.BeforeUpdate, TextBoxEventSource.DblClick, TextBoxEventSource.Dirty, TextBoxEventSource.Exit, TextBoxEventSource.KeyPress, TextBoxEventSource.Undo, ToggleButtonEventSource.BeforeUpdate, ToggleButtonEventSource.DblClick, ToggleButtonEventSource.Exit, ToggleButtonEventSource.KeyPress
        Command.Execute this.Source, Target, I1
    End Sub
    
    Private Sub EventHandlerII(I1 As Integer, I2 As Integer) Handles FormEventSource.ApplyFilter, FormEventSource.BeforeDelConfirm, FormEventSource.Error, FormEventSource.Filter
        Command.Execute this.Source, Target, I1, I2
    End Sub
    
    Private Sub EventHandlerIS(NewData As String, Response As Integer) Handles ComboBoxEventSource.NotInList
        Command.Execute this.Source, Target, Response, 0, NewData
    End Sub
    
    Private Sub GroupButton_KeyPress(KeyAscii As Integer) Handles OptionButtonEventSource.KeyPress, ToggleButtonEventSource.KeyPress
        If (KeyAscii = vbKeyReturn) Then   ' ENTER
            Target.Value = Not Target.Value
            Command.Execute this.Source, Target, KeyAscii
        End If
    End Sub
End Class

[Description("A command that cancels the current view")]
[COMCreatable(False)]
Class CancelCommand
Option Explicit
Private Const myClass = "CancelCommand"

    Implements IDisposable
    Implements ICommand
    
    Private this As TViewStore
    
    Sub New(ByVal View As IView)
        Set this.View = View
    End Sub

    '*************** INTERFACE ***************
    Private Sub IDisposable_Dispose()
        Set this.View = Nothing
    End Sub
    
    '*************** INTERFACE ***************
    Private Property Get ICommand_Description() As String
    End Property

    Private Sub ICommand_Execute(ByVal Context As Object, ByVal Target As Object, Optional I1 As Integer, Optional I2 As Integer, Optional S1 As String)
        If (Not (this.View.State = Submitted)) Then
            I1 = (MessageBox_("Are you sure you want to cancel?" & vbNL & "NOTE: All current data will be lost", vbApplicationModal Or vbQuestion Or vbYesNo, "Confirm Cancel") = IDNO)
            If I1 Then Exit Sub
            this.View.Cancel
        End If
    End Sub
End Class

[Description("A command that closes the application")]
[COMCreatable(False)]
Class QuitCommand
Option Explicit
Private Const myClass = "QuitCommand"
                          
    Implements ICommandEvaluator
    Implements IDisposable
    Implements ICommand
    
    Private this As TViewStore
    
    Sub New(ByVal View As IView)
        Set this.View = View
        this.Description = "Quit"
    End Sub

    Private Sub IDisposable_Dispose()
        Set this.View = Nothing
    End Sub

    '*************** INTERFACE ***************
    Private Function ICommandEvaluator_CanExecute(ByVal Source As Object) As Boolean
        ICommandEvaluator_CanExecute = (Not (CType(Of IViewModel)(Source).Manager.ProcessState = Processing))
    End Function

    '*************** INTERFACE ***************
    Private Property Get ICommand_Description() As String
        ICommand_Description = this.Description
    End Property

    Private Sub ICommand_Execute(ByVal Source As Object, ByVal Target As Object, Optional I1 As Integer, Optional I2 As Integer, Optional S1 As String)
        If (Not (this.View.State = Submitted)) Then
            If (MessageBox_("Are you sure you want to quit?" & vbNL & "NOTE: All current data will be lost", MB_APPLMODAL Or MB_YESNO Or MB_ICONQUESTION, "Confirm Quit") = IDYES) Then this.View.Quit
        End If
    End Sub
End Class
                                                      
[COMCreatable(False)]
Class SubmitCommand
Option Explicit
Private Const myClass = "SubmitCommand"
                          
    Implements ICommandEvaluator
    Implements IDisposable
    Implements ICommand
    
    Private this As TViewStore
    
    '****************** NEW ******************
    Sub New(ByVal View As IView, ByVal Description As String)
        Set this.View = View
        this.Description = Description
    End Sub
    
    '*************** INTERFACE ***************
    Private Sub IDisposable_Dispose()
        Set this.View = Nothing
    End Sub

    '*************** INTERFACE ***************
    Private Function ICommandEvaluator_CanExecute(ByVal Source As Object) As Boolean
        ICommandEvaluator_CanExecute = CType(Of IViewModel)(Source).Manager.Validation.IsValid
    End Function

    '*************** INTERFACE ***************
    Private Property Get ICommand_Description() As String
        ICommand_Description = this.Description
    End Property

    Private Sub ICommand_Execute(ByVal Source As Object, ByVal Target As Object, Optional I1 As Integer, Optional I2 As Integer, Optional S1 As String)
        this.View.Submit
    End Sub
End Class
                                               
[COMCreatable(False)]
Class WarningBadgeCommand
Option Explicit
Private Const myClass = "WarningBadgeCommand"

    Implements IGenericCommand
    Implements ICommand
    
    '*************** INTERFACE ***************
    Private Property Get ICommand_Description() As String
        ICommand_Description = "Dbl-click for errors"
    End Property

    Private Sub ICommand_Execute(ByVal Source As Object, ByVal Target As Object, Optional I1 As Integer, Optional I2 As Integer, Optional S1 As String)
        MessageBox_ CType(Of IHandleErrorMessage)(CType(Of IViewModel)(Source).Manager.Validation).Errors & vbLf & vbLf, vbApplicationModal Or vbCritical Or vbOKOnly, "Validation Errors"
    End Sub
End Class

[COMCreatable(False)]
Class SkipBlankCommand
Option Explicit
Private Const myClass = "SkipBlankCommand"

    Implements IGenericCommand
    Implements IDisposable
    Implements ICommand

    Private this As TFocusStore

    '****************** NEW ******************
    Sub New(ByVal Previous As String, ByVal Label As Access.Label, ByVal Source As Object, ByVal Focus As Access.Control)
        this.Previous = Previous
        Set this.Label = Label
        Set this.Source = Source
        Set this.Focus = Focus
    End Sub
    
    '*************** INTERFACE ***************
    Private Sub IDisposable_Dispose()
        Set this.Label = Nothing
        Set this.Source = Nothing
        Set this.Focus = Nothing
    End Sub

    '*************** INTERFACE ***************
    Private Property Get ICommand_Description() As String
    End Property
    
    Private Sub ICommand_Execute(ByVal Source As Object, ByVal Target As Object, I1 As Integer, I2 As Integer, S1 As String)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".Execute"
    '==================================================================
     1  If (Not (AppManager.Access.App.Screen.PreviousControl.Name = this.Previous)) Then
     2      this.Label.ForeColor = FOCUSED_LABEL_FORECOLOR
     3  Else
     4      If IsNull(this.Source) Then
     5          this.Focus.SetFocus
            Else
     6          this.Label.ForeColor = FOCUSED_LABEL_FORECOLOR
            End If
        End If
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
        Err.Clear
    End Sub
End Class

[COMCreatable(False)]
Class PaginationCommand
Option Explicit
Private Const myClass = "PaginationCommand"

    Implements IDisposable
    Implements ICommand

    Private this As TFocusStore

    '****************** NEW ******************
    Sub New(ByVal Previous As String, ByVal Label As Access.Label, ByVal Source As Object, ByVal Focus As Access.Control)
        this.Previous = Previous
        Set this.Label = Label
        Set this.Source = Source
        Set this.Focus = Focus
    End Sub
    
    '*************** INTERFACE ***************
    Private Sub IDisposable_Dispose()
        Set this.Label = Nothing
        Set this.Source = Nothing
        Set this.Focus = Nothing
    End Sub

    '*************** INTERFACE ***************
    Private Property Get ICommand_Description() As String
    End Property
    
    Private Sub ICommand_Execute(ByVal Source As Object, ByVal Target As Object, I1 As Integer, I2 As Integer, S1 As String)
    '==================================================================
    On Error GoTo ERR_
    Const myName = myClass & ".Execute"
    '==================================================================
    1  If (Not (AppManager.Access.App.Screen.PreviousControl.Name = this.Previous)) Then
    2      this.Label.ForeColor = FOCUSED_LABEL_FORECOLOR
    3  Else
    4      If this.Source.Enabled Then
    5           this.Focus.SetFocus
            Else
    6           this.Label.ForeColor = FOCUSED_LABEL_FORECOLOR
            End If
        End If
        Exit Sub
    '==================================================================
    ERR_:
        HandleError myName
        Err.Clear
    End Sub
End Class

[COMCreatable(False)]
Class RelatedCommand
Option Explicit
                       
    Implements IDisposable
    Implements ICommand
    
    Private Type TInternal
        Parent As Access.Form
        FindForm As String
        FilterProperty As String
        Related As Access.AccessField
    End Type
    
    Private this As TInternal
    
    Sub New(ByVal Parent As Access.Form, ByVal FindForm As String, ByVal FilterProperty As String, ByVal Related As Access.AccessField)
        Set this.Parent = Parent
        this.FindForm = FindForm
        this.FilterProperty = FilterProperty
        Set this.Related = Related
    End Sub
    
    Private Sub IDisposable_Dispose()
        Set this.Parent = Nothing
        Set this.Related = Nothing
    End Sub
    
    Private Property Get ICommand_Description() As String
    End Property
    
    Private Sub ICommand_Execute(ByVal Source As Object, ByVal Target As Object, I1 As Integer, I2 As Integer, S1 As String)
        If this.Parent.IsDirty Then this.Parent.IsDirty = False
        With AppManager.Access.App.DoCmd
            .OpenForm this.FindForm, acNormal, , "[" & this.FilterProperty & "] = " & CStr(CallByName(Source, this.FilterProperty, vbGet)), , acDialog, Join(this.Related.Value, ",")
            .Requery()
        End With
    End Sub
End Class

Module LibCommands
Option Explicit
Private Const myModule = "LibCommands"

    Public Type TViewStore
        View As IView
        Description As String
    End Type
    
    Public Type TFocusStore
        Previous As String
        Label As Access.Label
        Source As Object
        Focus As Access.Control
    End Type
End Module
